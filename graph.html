<html>
<script src='js/three.min.js'></script>
<script src='js/jquery.js'></script>
<script src='js/d3.js'></script>
<script src='js/CanvasRenderer.js'></script>
<script src='js/TrackballControls.js'></script>
<script src='js/Projector.js'></script>
<script src='js/stats.js'></script>
<script src='js/queue.js'></script>
<style>
html, body {
  margin: 0;
  padding: 0;
  font-family: 'Helvetica Neue';
  color: #ffffff;
  text-transform: uppercase;
  font-size: 10px;
  background-color: #000;
  overflow: hidden;
}
#controls {
  position: absolute;
  top: 0;
  left: 0;
  padding: 10px;
}
  #controls select {
    width: 100px;
  }
  #search {
    border-radius: 3px;
    height: 18px;
    width: 100px;
    border: 1px solid #666;
    color: #000;
    padding-left: 8px;
  }
#navigation {
  position: absolute;
  top: 0;
  left: 0;
  padding: 10px;
}
  #navigation .nav {
    margin: 0;
    cursor: pointer;
    margin-bottom: -5px;
  }
  #navigation .nav.inactive {
    color: #666;
  }
  #navigation .nav:hover {
    color: #00c4f4;
  }
#left {
  position: relative;
  float: left;
  display: inline-block;
  width: 50%;
  height: 100%;
  background-color: #333;
  margin: 0;
  padding: 0;
}
#graph {
  width: 100%;
  height: 100%;
  border-bottom: 1px solid #000;
  overflow: hidden;
}
#matrix {
  width: 200px;
  height: 200px;
  overflow: hidden;
  position: absolute;
  bottom: 0;
  left: 0;
}
#model {
  position: relative;
  float: left;
  display: inline-block;
  width: 50%;
  height: 100%;
  background-color: #000;
  padding: 0;
  overflow: hidden;
}
.node {
  cursor: pointer;
}
.link {
  cursor: pointer;
}
#linear {
  position: absolute;
  width: 100%;
  height: 100px;
  left: 0;
  bottom: 0;
}
#unpin {
  position: absolute;
  width: 30px;
  height: 20px;
  right: 10px;
  top: 10px;
  font-size: 20px;
  cursor: pointer;
  visibility: hidden;
}
  #unpin:hover {
    color: #00c4f4;
  }
#wireframe {
  position: absolute;
  right: 10px;
  bottom: 10px;
  color: #666;
  cursor: pointer;
}
#lookup {
  position: absolute;
  left: 20px;
  bottom: 35px;
  visibility: hidden;
}
.icon {
  font-size: 20px;
}
.button {
  cursor: pointer;
}
.button:hover {
  color: #00c4f4;
}
</style>
<body>
  <!-- <div id='matrix'>
  </div> -->
  <div id='left'>
    <div id='controls'>
      <span class='icon'>&ocir; </span> <select id='node'>
        <option value='chromosome'>chromosome</option>
        <option value='1Mb'>1Mb</option>
      </select><br>
      <span class='icon'>&origof; </span> <select id='link'>
        <option value='weighted'>distance/bin</option>
        <option value='distance'>distance</option>
      </select><br>
      <span class='icon'>&xopf; </span>&nbsp;<input id='search' type='text'></input>
      <br>
    </div>
    <div id='unpin'>&Cross; &cirmid;</div>
    <!-- <div id='lookup' class='button'><span class='icon'>&supsub;</span> ucsc gb</div> -->
    <div id='linear'></div>
    <div id='graph'></div>
  </div>
  <div id='model'>
    <div id='wireframe'>toggle lamina <span class='icon'>&smashp;</span></div>
    <div id='navigation'>
      <div class='nav'><span class='icon'>&oast;</span> genome</div>
    </div>
  </div>
</body>
<script type='x-shader/x-vertex' id='vertexShader'>
varying vec2 vUv;
varying float noise;
attribute float alpha;
varying float vAlpha;
varying vec3 vColor;
void main() {
  vAlpha = alpha;
  vUv = uv;
  vColor = color;
  gl_PointSize = 1.1;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
</script>
<script type="x-shader/x-fragment" id="fragmentShader">
varying vec2 vUv;
varying float noise;
varying float vAlpha;
varying vec3 vColor;
uniform vec3 colorsa;
void main() {
  gl_FragColor = vec4(vColor, vAlpha);
}
</script>
<script>

var rainbow = d3.scale.category20(),

    resolution = '1Mb',
    cgSize = 300,
    graphCap = 1000,
    graphThreshold = 4,
    mapCap,

    graph = {},
    linear = {},
    width = window.innerWidth,
    initialWidth = window.innerWidth,
    height = window.innerHeight,
    initialHeight = window.innerHeight,

    all = [],
    pdb = [],
    segments = [],
    rap = [],
    chromosomes = [],
    meshes = [],
    bufferGeometry = [],
    loaded = {},

    pinned = 0,
    navigation = [],
    navigated = 0,

    scene,
    camera,
    renderer,
    controls,
    genome,
    sphere,
    raycaster = new THREE.Raycaster(),
    mouse = new THREE.Vector2(),
    click = new THREE.Vector2(),
    shifting = false,
    dragging = false,

    zoomToBin = 8,
    graphed = false,
    launch = true

var zoom = d3.behavior.zoom()
  .scaleExtent([1, 20])
  .on('zoom', zoomed)

var stats = new Stats()
stats.showPanel(1)
document.body.appendChild(stats.dom)

loadPDB('1Mb')

function loadPDB(resolution) {
  all = []
  pdb = []
  segments = []
  rap = []
  chromosomes = []

  var q = queue(1)
  q.defer(d3.text, 'data/Model_' + resolution + '.pdb')
  q.defer(d3.text, 'data/Model_' + resolution + '.pml')
  q.defer(d3.text, 'data/0hr-Xist_' + resolution)
  q.defer(d3.text, 'data/1hr-Xist_' + resolution)
  q.defer(d3.text, 'data/2hr-Xist_' + resolution)
  q.defer(d3.text, 'data/3hr-Xist_' + resolution)
  q.defer(d3.text, 'data/6hr-Xist_' + resolution)
  q.awaitAll(function(error, results){
      segments = results[1].split('\n')
      for (var i = segments.length - 1; i >= 0; i--) {
        var line = segments[i]
        if (line.substring(0, 6) != "select") segments.splice(i, 1)
        else {
          var split = segments[i].split(' ')[2].split('-')
          segments[i] = [parseInt(split[0]) - 1, parseInt(split[1]) - 1]
        }
      }
      segments.reverse()
      var length = segments.length
      var last = segments[length - 1][1]
      for (var i = 0; i < length; i++) {
        chromosomes.push({
          'chromosome': i,
          'contacts': new Array(resolution == '40kb' ? length * 2 : length)
        })
        if (resolution == '40kb') segments.push([segments[i][0] + last, segments[i][1] + last])
      }
      pdb = results[0].split('\n')
      chromosome = 0
      for (var i = 0; i < pdb.length - 1; i++) {
        if (i > segments[chromosome][1]) chromosome++
        all.push({
          'chromosome': chromosome,
          'bin': i,
          'x3': parseFloat(pdb[i].substring(31,37)),
          'y3': parseFloat(pdb[i].substring(38,45)),
          'z3': parseFloat(pdb[i].substring(46,53)),
          'lamina': parseInt(pdb[i].substring(61,64)),
          'rap0': 0.0,
          'rap1': 0.0,
          'rap2': 0.0,
          'rap3': 0.0,
          'rap4': 0.0,
        })
      }
      loaded['lamina'] = true
      for (var d = 0; d < 5; d++) {
        loaded['rap' + d] = true
        rap = results[d + 2].split('\n')
        for (var i = 0; i < rap.length - 1; i++) {
          var split = rap[i].split('\t')
          var bin = segments[parseInt(split[0]) - 1][0] + (parseInt(split[1]) / (resolution == '1Mb' ? 1000000 : 40000))
          all[bin]['rap' + d] = parseFloat(split[4])
        }
      }
      for (var a = 0; a < all.length; a++) {
        var binA = all[a]
        binA.contacts = []
        for (var b = 0; b < all.length; b++) {
          if (a == b) continue
          var binB = all[b]
          var distance = distanceToSquared(binA.x3, binA.y3, binA.z3, binB.x3, binB.y3, binB.z3)
          binA.contacts.push(distance)

          var ic = chromosomes[binA.chromosome].contacts[binB.chromosome]
          chromosomes[binA.chromosome].contacts[binB.chromosome] = ic == null ? 0 : ic + distance
        }
      }
      for (var i = 0; i < chromosomes.length; i++) {
        var binsA = segments[i][1] - segments[i][0]
        chromosomes[i].weighted = [] // this is fair but isolates non-localized chromosomes (like active X)
        for (var j = 0; j < chromosomes[i].contacts.length; j++) {
          var binsB = segments[j][1] - segments[j][0]
          chromosomes[i].weighted.push(chromosomes[i].contacts[j] / (binsA + binsB))
        }
      }
      if (launch) init()
      // plotGenome()
      graphGenome()
      modelGenome()
    })
}

function init() {
  launch = false

  graph.svg = d3.select('#graph').append('svg')
    .attr('width', width / 2)
    .attr('height', height)
  graph.floor = graph.svg.append('g')
    .call(zoom)
    .on('mousedown.zoom', null)
  graph.floor.append('rect')
    .attr('width', width / 2)
    .attr('height', height)
    .attr('opacity', 0)
  graph.container = graph.svg.append('g')
  graph.layer1 = graph.container.append('g')
  graph.layer2 = graph.container.append('g')
  graph.layer3 = graph.container.append('g')
  graph.layer4 = graph.container.append('g')

  // matrix.svg = d3.select('#matrix').append('svg')
  //   .attr('width', 200)
  //   .attr('height', 200)
  // matrix.layer1 = matrix.svg.append('g')
  // matrix.layer2 = matrix.svg.append('g')

  linear.svg = d3.select('#linear').append('svg')
    .attr('width', width / 2)
    .attr('height', 100)

  scene = new THREE.Scene()
  camera = new THREE.PerspectiveCamera(75, width / height / 2, 1, 20000)
  scene.add(camera)
  renderer = new THREE.WebGLRenderer()
  renderer.setSize(width / 2, height)
  d3.select('#model')[0][0].appendChild(renderer.domElement)
  controls = new THREE.TrackballControls(camera, renderer.domElement)

  sphere = new THREE.Mesh(new THREE.SphereGeometry(11.5, 30, 30), new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true, transparent: true, opacity: 0.1 }))
  sphere.visible = false
  scene.add(sphere)

  window.addEventListener('resize', onWindowResize, false)
  document.addEventListener('mousemove', onDocumentMouseMove, false)
  document.addEventListener('mousedown', onDocumentMouseDown, false)
  document.addEventListener('mouseup', onDocumentMouseUp, false)
  document.addEventListener('keyup', onDocumentKeyUp, false)
  document.addEventListener('keydown', onDocumentKeyDown, false)

  navigation.push({
    'context': 'genome',
    'node': 'chromosome',
    'link': 'weighted',
    'locus': new THREE.Vector3(0, 0, 0),
  })

  $('#navigation').on('click', '.nav', function(){
    navigate($('#navigation>.nav').index(this))
  })

  $('#unpin').on('click', function() {
    var nodes = navigation[navigated].context == 'genome' ? graph.genome.nodes : graph.chromosomes.nodes
    for (var i = 0; i < nodes.length; i++) nodes[i].pinned = false
    pinned = 0
    d3.selectAll('.node').attr('opacity', 1)
    linear.svg.selectAll('.active').filter('.highlight').remove()
    alphaModel(0.8, navigation[navigated].chromosomes)
    $(this).css('visibility', 'hidden')
    $('#lookup').css('visibility', 'hidden')
  })

  $('#wireframe').on('click', function() {
    sphere.visible = !sphere.visible
    $(this).css('color', sphere.visible ? '#fff' : '#666')
  })

  animate()

}

function navigate(nav) {
  $('#navigation>.nav').addClass('inactive')
  $('#navigation>.nav:eq(' + nav + ')').removeClass('inactive')

  controls.target.copy(navigation[nav].locus)
  camera.position.copy(navigation[nav].locus)
  camera.position.setZ(30)
  graph.container.attr('transform', 'scale(1)')

  if (navigation[nav].context == 'genome') {
    graphGenome()
    alphaModel(0.8)
    linear.svg.selectAll('.chromosome').remove()
    $('#unpin').css('visibility', 'hidden')
  } else if (navigation[nav].context == 'chromosomes') {
    if (navigation[navigated].chromosomes != navigation[nav].chromosomes) graphChromosomes(navigation[nav].chromosomes)
    d3.selectAll('.node').attr('opacity', 1)
    alphaModel(0.8, navigation[nav].chromosomes)
    $('#unpin').css('visibility', 'hidden')
  } else if (navigation[nav].context == 'bins') {
    if (navigation[navigated].chromosomes != navigation[nav].chromosomes) graphChromosomes(navigation[nav].chromosomes)
    for (var i = 0; i < navigation[nav].nodes.length; i++) {
      graph.chromosomes.nodes[navigation[nav].nodes[i]].pinned = true
      pinned++
    }
    d3.selectAll('.node').attr('opacity', function(d){ return d.pinned ? 1 : 0.3 })
    alphaModel(0.8, navigation[nav].chromosomes)
    alphaModelFromGraph()
    $('#unpin').css('visibility', 'visible')
  }

  $('#node').val(navigation[nav].node)
  $('#link').val(navigation[nav].link)

  navigated = nav
}

function search(query) {
  $('#search').val("")
  // TODO: pinned-specific search?
  if (!loaded[query]) return alert("search not found")

  if (navigation[navigated].context == 'genome') {
    var nodes = graph.genome.nodes
    for (var i = 0; i < chromosomes.length; i++) {
      var segment = segments[i]
      chromosomes[i].found = 0
      for (var j = segment[0]; j < segment[1]; j++) {
        chromosomes[i].found += all[j][query]
      }
      chromosomes[i].found /= (segment[1] - segment[0])
    }
    max = 0
    for (var i = 0; i < chromosomes.length; i++) {
      if (chromosomes[i].found > max) max = chromosomes[i].found
    }
    graph.svg.selectAll('.node').attr('opacity', function(d){ return atLeast(d.found / max, 0.2) })
    for (var i = 0; i < chromosomes.length; i++) {
      var alphas = new Float32Array(bufferGeometry[i].attributes.alpha.count)
      for (var a = 0; a < bufferGeometry[i].attributes.alpha.count; a++) alphas[a] = atLeast(chromosomes[i].found / max, 0.2)
      bufferGeometry[i].attributes.alpha = new THREE.BufferAttribute(alphas, 1)
    }
  } else if (navigation[navigated].context == 'chromosomes') {
    var nodes = graph.chromosomes.nodes
    max = 0
    for (var i = 0; i < nodes.length; i++) {
      nodes[i].found = all[nodes[i].bin][query]
      if (nodes[i].found > max) max = nodes[i].found
    }
    graph.svg.selectAll('.node').attr('opacity', function(d){ return atLeast(d.found / max, 0.3) })
    alphaModelFromGraph(max)
  }
}

function modelGenome() {

  scene.remove(genome)
  genome = new THREE.Object3D()
  meshes = []

  for (var i = 0; i < segments.length; i++) {
    var segment = segments[i]
    var curve = new THREE.CatmullRomCurve3(
      all.slice(segment[0], segment[1]).map(function(values, bin){
        return new THREE.Vector3((values.x3 - 100), (values.y3 - 100), (values.z3 - 100))
      })
    )

    var geometry = new THREE.TubeGeometry(
      curve,  //path
      (segments[i % segments.length][1] - segments[i % segments.length][0]) * (resolution == '1Mb' ? 5 : 2),    //segments
      resolution == '1Mb' ? 0.05 : 0.1,     //radius
      3,     //radiusSegments
      false  //closed
    )
    bufferGeometry[i] = new THREE.BufferGeometry().fromGeometry(geometry)
    var alphas = new Float32Array(bufferGeometry[i].attributes.position.count)
    var colors = new Float32Array(bufferGeometry[i].attributes.position.count * 3)
    var color = d3.rgb(rainbow(i))
    for (var v = 0; v < bufferGeometry[i].attributes.position.count; v++) {
      alphas[v] = 0.8
      colors[(v * 3)] = color.r / 255
      colors[(v * 3) + 1] = color.g / 255
      colors[(v * 3) + 2] = color.b / 255
    }
    bufferGeometry[i].attributes.alpha = new THREE.BufferAttribute(alphas, 1)
    bufferGeometry[i].attributes.color = new THREE.BufferAttribute(colors, 3)
    material = new THREE.ShaderMaterial({
      vertexShader: document.getElementById('vertexShader').textContent,
      fragmentShader: document.getElementById('fragmentShader').textContent,
      vertexColors: THREE.VertexColors,
      transparent: true,
    })
    meshes[i] = new THREE.Mesh(bufferGeometry[i], material)
    meshes[i].name = i
    genome.add(meshes[i])
  }
  scene.add(genome)

  camera.position.z = resolution == '1Mb' ? 30 : 60

}

function plotGenome() {
  var size = 200 / 40

  var mg = matrix.genome = {}

  var row = matrix.layer1.selectAll('.row')
    .data(chromosomes)
  var rowEnter = row.enter().append('g')
    .attr('transform', function(d,i){ return 'translate(0,' + (d.chromosome * size) + ')' })
    .attr('class', 'row')
  rowEnter.each(function(d){
    var rowThis = d3.select(this)
    d.weighted.forEach(function(contact,c){
      contact = 255 - contact / 25
      rowThis.append('rect')
        .attr('width', size)
        .attr('height', size)
        .attr('y', 0)
        .attr('x', c * size)
        .attr('fill', d.chromosome == c ? rainbow(c) : d3.rgb(contact, contact, contact))
    })
  })
}

function graphGenome() {
  graph.svg.selectAll('.node,.link').remove()
  pinned = 0
  for (var i = 0; i < chromosomes.length; i++) chromosomes[i].pinned = false

  var gg = graph.genome = {}
  gg.force = d3.layout.force()
    .size([width / 2, height])
    .charge(-300)
    .linkStrength(function(d){ return Math.sqrt(d.distance) / 500 })
  gg.nodes = chromosomes
  gg.links = []
  gg.linked = {}

  for (var i = 0; i < gg.nodes.length; i++) {
    var chromosome = gg.nodes[i]
    for (var j = 0; j < gg.nodes.length; j++) {
      if (chromosome.weighted[j] < 6000 && gg.linked[j] == null) {
        gg.links.push({'source': i, 'target': j, 'distance': chromosome.weighted[j]})
        gg.linked[i] = true
      }
    }
  }

  var node = graph.layer2.selectAll('.node')
    .data(gg.nodes)
  var nodeEnter = node.enter().append('g')
    .attr('class', 'node chromosome')
  nodeEnter.append('circle')
    .attr('r', 8)
    .attr('stroke', '#333')
    .attr('stroke-width', 3)
    .attr('fill', function(d,i){ return rainbow(i) })
  nodeEnter.append('text')
    .text(function(d,i){ return chromosomeName(i) })
    .attr('fill', '#333')
    .attr('font-size', '8px')
    .attr('y', 3)
    .attr('text-anchor', 'middle')
    .attr('font-weight', 700)
  nodeEnter.on('mouseover', function(d){
    if (pinned == 0) d3.selectAll('.chromosome').attr('opacity', 0.2)
    else d3.selectAll('.chromosome').attr('opacity', function(d,i){ return d.pinned ? 1 : 0.2 })
    d3.select(this).attr('opacity', 1)
    for (var i = 0; i < segments.length; i++) {
      var alphas = new Float32Array(bufferGeometry[i].attributes.alpha.count)
      if (i == d.chromosome || chromosomes[i].pinned) for (var a = 0; a < bufferGeometry[i].attributes.alpha.count; a++) alphas[a] = 0.8
      else for (var a = 0; a < bufferGeometry[i].attributes.alpha.count; a++) alphas[a] = 0.2
      bufferGeometry[i].attributes.alpha = new THREE.BufferAttribute(alphas, 1)
    }
    if (!d.pinned) linear.svg.append('rect')
      .attr('fill', rainbow(d.chromosome))
      .attr('rx', 5)
      .attr('x', 20 + (segments[d.chromosome][0]) * linear.ratio)
      .attr('y', 70)
      .attr('width', atLeast((segments[d.chromosome][1] - segments[d.chromosome][0]) * linear.ratio, 10))
      .attr('height', 10)
      .attr('class', 'active highlight chr' + d.chromosome + '-all')
  })
  nodeEnter.on('mouseout', function(d){
    if (pinned == 0) d3.selectAll('.chromosome').attr('opacity', 1)
    else d3.selectAll('.chromosome').attr('opacity', function(d,i){ return d.pinned ? 1 : 0.2 })
    for (var i = 0; i < segments.length; i++) {
      var alphas = new Float32Array(bufferGeometry[i].attributes.alpha.count)
      if (pinned == 0 || chromosomes[i].pinned) for (var a = 0; a < bufferGeometry[i].attributes.alpha.count; a++) alphas[a] = 0.8
      else for (var a = 0; a < bufferGeometry[i].attributes.alpha.count; a++) alphas[a] = 0.2
      bufferGeometry[i].attributes.alpha = new THREE.BufferAttribute(alphas, 1)
    }
    linear.svg.selectAll('.chr' + d.chromosome + '-all').filter(function(o){ return !d3.select(this).classed('pinned') }).remove()
  })
  nodeEnter.on('click', function(d){
    d.pinned = !d.pinned
    if (d.pinned) pinned++
    else pinned--
    chromosomes[d.chromosome] = d
    linear.svg.selectAll('.chr' + d.chromosome + '-all').classed('pinned', d.pinned)
    $('#unpin').css('visibility', pinned == 0 ? 'hidden' : 'visible')
  })

  var link = graph.layer1.selectAll('.link')
    .data(gg.links).enter().append('line')
    .attr('stroke-width', 2)
    .attr('stroke', '#555')
    .attr('opacity', 1)
    .attr('class', 'link interchromosomal')

  graph.context = makeAbsoluteContext(graph.layer2[0][0], graph.svg[0][0])

  gg.force
    .nodes(gg.nodes)
    .links(gg.links)
    .start()
  for (var i = 0; i < Math.pow(gg.nodes.length, 2); i++) gg.force.tick()
  gg.force.stop()
  node
    .attr('transform', function(d,i){ return 'translate(' + d.x + ',' + d.y + ')'})
  link
    .attr('x1', function(d){ return d.source.x })
    .attr('y1', function(d){ return d.source.y })
    .attr('x2', function(d){ return d.target.x })
    .attr('y2', function(d){ return d.target.y })

  linear.svg.line = linear.svg.append('rect')
    .attr('rx', 5)
    .attr('width', (width / 2) - 50)
    .attr('height', 10)
    .attr('x', 20)
    .attr('y', 70)
    .attr('fill', '#222')

  linear.ratio = 1 / segments[segments.length - 1][1] * ((width / 2) - 50)
  linear.lit = {}
}

function graphChromosomes(chr) {
  graph.svg.selectAll('.node,.link').remove()
  pinned = 0
  for (var i = 0; i < chromosomes.length; i++) chromosomes[i].pinned = false

  linear.svg.selectAll('.highlight').attr('fill', '#444').classed('active', false)

  graphed = true
  var cg = graph.chromosomes = {}
  cg.force = d3.layout.force()
    .size([width / 2, height])
    .linkDistance(function(d){ return d.distance * 3 })
    // .linkStrength(10)
    // .charge(-100)
  cg.nodes = []
  cg.nodesDict = {}
  cg.links = []
  cg.linked = {}
  cg.chr = chr

  for (var i = 0; i < chr.length; i++) {
    var segment = segments[chr[i]]
    for (var j = segment[0]; j < segment[1]; j++) {
      cg.nodes.push(all[j])
      cg.nodesDict[chr[i] + ':' + (j - segment[0])] = cg.nodes.length - 1
    }
  }

  for (var i = 0; i < cg.nodes.length; i++) {
    cg.nodes[i].pinned = false
    var bin = cg.nodes[i]
    for (var j = 0; j < cg.nodes.length; j++) {
      if (i == j) continue
      var con = cg.nodes[j].bin
      if (bin.contacts[con] < 5 && cg.linked[con] == null) {
        cg.links.push({
          'source': i,
          'target': j,
          'distance': bin.contacts[con],
          'physical': Math.abs(j - i) == 1 && cg.nodes[i].chromosome == cg.nodes[j].chromosome ? cg.nodes[i].chromosome : false
        })
        cg.linked[bin.bin] = true
      }
    }
  }

  var node = graph.layer2.selectAll('.node')
    .data(cg.nodes)
  var nodeEnter = node.enter().append('g')
    .attr('class', 'node bin')
    .attr('opacity', function(d){ return (pinned == 0 || d.pinned) ? 1 : 0.2 })
  nodeEnter.append('circle')
    .attr('r', 3)
    .attr('stroke', '#333')
    .attr('stroke-width', 2)
    .attr('fill', function(d){ return rainbow(d.chromosome) })
  nodeEnter.on('mouseover', function(d){
    if (pinned == 0) d3.selectAll('.node').attr('opacity', 0.2)
    else d3.selectAll('.node').attr('opacity', function(d,i){ return d.pinned ? 1 : 0.2 })
    d3.select(this).attr('opacity', 1)
    for (var i = 0; i < chr.length; i++) {
      var segment = segments[chr[i]]
      var geometry = bufferGeometry[chr[i]]
      var mesh = meshes[chr[i]]
      var total = geometry.attributes.alpha.count
      var bins = segment[1] - segment[0]
      var size = parseInt(total / bins)
      for (var j = segment[0]; j < segment[1]; j++) {
        if (j == d.bin || all[j].pinned) for (var k = (j - segment[0]) * size; k < (j + 1 - segment[0]) * size; k++) geometry.attributes.alpha.array[k] = 0.8
        else for (var k = (j - segment[0]) * size; k < (j + 1 - segment[0]) * size; k++) geometry.attributes.alpha.array[k] = 0.2
      }
      geometry.attributes.alpha.needsUpdate = true
    }
    if (!d.pinned) linear.svg.append('line')
      .attr('stroke', rainbow(d.chromosome))
      .attr('x1', 20 + d.bin * linear.ratio)
      .attr('x2', 20 + d.bin * linear.ratio)
      .attr('y1', 70 + 0)
      .attr('y2', 70 + 10)
      .attr('class', 'active highlight chr' + d.chromosome + '-' + d.bin)
  })
  nodeEnter.on('mouseout', function(d){
    if (pinned == 0) d3.selectAll('.node').attr('opacity', 1)
    else d3.selectAll('.node').attr('opacity', function(d,i){ return d.pinned ? 1 : 0.2 })
    for (var i = 0; i < chr.length; i++) {
      var segment = segments[chr[i]]
      var geometry = bufferGeometry[chr[i]]
      var mesh = meshes[chr[i]]
      var total = geometry.attributes.alpha.count
      var bins = segment[1] - segment[0]
      var size = parseInt(total / bins)
      for (var j = segment[0]; j < segment[1]; j++) {
        if (pinned == 0 || all[j].pinned) for (var k = (j - segment[0]) * size; k < (j + 1 - segment[0]) * size; k++) geometry.attributes.alpha.array[k] = 0.8
        else for (var k = (j - segment[0]) * size; k < (j + 1 - segment[0]) * size; k++) geometry.attributes.alpha.array[k] = 0.2
      }
      geometry.attributes.alpha.needsUpdate = true
    }
    linear.svg.selectAll('.chr' + d.chromosome + '-' + d.bin).filter(function(o){ return !d3.select(this).classed('pinned') }).remove()
  })
  nodeEnter.on('click', function(d){
    d.pinned = !d.pinned
    if (d.pinned) pinned++
    else pinned--
    all[d.bin] = d
    linear.svg.selectAll('.chr' + d.chromosome + '-' + d.bin).classed('pinned', d.pinned)
    $('#unpin').css('visibility', pinned == 0 ? 'hidden' : 'visible')
  })

  var link = graph.layer1.selectAll('.link')
    .data(cg.links).enter().append('line')
    .attr('stroke-width', 1)
    .attr('stroke', function(d){ return d.physical || d.physical === 0 ? rainbow(d.physical) : '#fff' })
    .attr('opacity', function(d){ return d.physical || d.physical === 0 ? 1 : 0.2 })
    .attr('class', 'link interbin')

  cg.force
    .nodes(cg.nodes)
    .links(cg.links)
    .start()
  for (var i = 0; i < Math.pow(cg.nodes.length, 2); i++) cg.force.tick()
  cg.force.stop()
  node
    .attr('transform', function(d,i){ return 'translate(' + d.x + ',' + d.y + ')'})
  link
    .attr('x1', function(d){ return d.source.x })
    .attr('y1', function(d){ return d.source.y })
    .attr('x2', function(d){ return d.target.x })
    .attr('y2', function(d){ return d.target.y })

  linear.svg.chromosomes = {}
  var longest = segments[0][1] - segments[0][0]
  for (var i = 0; i < chr.length; i++) {
    var c = chr[i]
    var chromosome = linear.svg.append('g')
      .attr('transform', 'translate(0,' + (70 - ((i + 1) * 15)) + ')')
      .attr('class', 'chromosome')
      .on('mouseleave', function(){
        linear.svg.chromosomes[c].selectAll('.box').remove()
      })
      .on('mouseenter', function(){
        var highlighted = []
        var nodes = graph.chromosomes.nodes
        var i = 0
        var start = null
        while (i < nodes.length - 1) {
          if (start == null && nodes[i].pinned && nodes[i + 1].pinned) start = i
          else if (start != null && nodes[i].pinned && !nodes[i + 1].pinned) {
            highlighted.push([start, i])
            start = null
          }
          i++
        }
        if (start != null) highlighted.push([start, i])
        var ratio = 1 / (segments[0][1] - segments[0][0]) * ((width / 2) - 70)
        linear.svg.chromosomes[c].selectAll('.box')
          .data(highlighted).enter().append('rect')
          .attr('class', 'box')
          .attr('cursor', 'pointer')
          .attr('stroke', '#fff')
          .attr('fill', 'transparent')
          .attr('rx', 2)
          .attr('x', function(d){
            var nodeA = nodes[d[0]]
            var start = 15 + 20 + (nodeA.bin - segments[nodeA.chromosome][0]) * ratio
            return start
          })
          .attr('height', 10)
          .attr('width', function(d){
            var nodeA = nodes[d[0]]
            var nodeB = nodes[d[1]]
            var start = 15 + 20 + (nodeA.bin - segments[nodeA.chromosome][0]) * ratio
            var end = 15 + 20 + (nodeB.bin - segments[nodeB.chromosome][0]) * ratio
            return end - start
          })
          .on('click', function(d){
            lookup(c, d)
          })
      })
    chromosome.append('rect')
      .attr('rx', 5)
      .attr('width', 10)
      .attr('height', 10)
      .attr('x', 20)
      .attr('y', 0)
      .attr('fill', rainbow(c))
      .attr('cursor', 'pointer')
      // .on('click', function(){ lookup(c) })
    chromosome.append('text')
      .text(chromosomeName(c))
      .attr('fill', '#333')
      .attr('font-size', 6)
      .attr('x', 25)
      .attr('y', 7.5)
      .attr('text-anchor', 'middle')
      .attr('pointer-events', 'none')
      .attr('font-weight', 500)
    chromosome.append('rect')
      .attr('rx', 5)
      .attr('width', (segments[c][1] - segments[c][0]) / longest * ((width / 2) - 70))
      .attr('height', 10)
      .attr('x', 35)
      .attr('fill', '#222')
    linear.svg.chromosomes[c] = chromosome
  }
}

function animate() {
  requestAnimationFrame(animate)
  stats.begin()
  controls.update()
  render()
  stats.end()
}

function render() {
  renderer.render(scene, camera)
}

function onWindowResize() {
  width = window.innerWidth
  height = window.innerHeight
  graph.container.attr('transform', 'translate(' + ((width - initialWidth) / 4) + ',0)scale(' + (height / initialHeight) + ')')
  graph.svg.attr('width', width / 2).attr('height', height)
  linear.svg.attr('width', width / 2)
  linear.svg.line.attr('width', (width / 2) - 50)
  camera.aspect = width / height / 2
  camera.updateProjectionMatrix()
  renderer.setSize(width / 2, height)
}

function onDocumentMouseMove(event) {
  event.preventDefault()
  mouse.x = ((event.clientX - (width / 2)) / renderer.domElement.clientWidth) * 2 - 1
  mouse.y = -(event.clientY / renderer.domElement.clientHeight) * 2 + 1

  if (!shifting && dragging) {
    var a = {'x': click.x, 'y': click.y}
    var b = {'x': event.clientX, 'y': event.clientY}
    var x1 = a.x < b.x ? a.x : b.x
    var x2 = a.x > b.x ? a.x : b.x
    var y1 = a.y < b.y ? a.y : b.y
    var y2 = a.y > b.y ? a.y : b.y
    graph.marquee
      .attr('x', x1)
      .attr('y', y1)
      .attr('width', x2 - x1)
      .attr('height', y2 - y1)
  }

  raycaster.setFromCamera(mouse, camera)
  var intersections = raycaster.intersectObjects(genome.children)
  var intersection = intersections.length > 0 ? intersections[0] : null

  if (shifting && intersection !== null && intersection.object.visible && intersection.object.name !== "") {
    if (pinned == 0 && navigation[navigated].context == 'chromosomes') {
      var chromosome = intersection.object.name
      var faceIndex = intersection.faceIndex
      var total = bufferGeometry[chromosome].attributes.alpha.count
      var bins = segments[chromosome][1] - segments[chromosome][0]
      var bin = parseInt(faceIndex / total * bins)
      alphaModel(0.2)
      alphaBin(chromosome, bin, 1)
      var node = graph.chromosomes.nodesDict[chromosome + ':' + bin]
      graph.svg.selectAll('.node').attr('opacity', function(d,i){ return i == node ? 1 : 0.2 })
    }
  }
}

function onDocumentMouseDown(event) {
  graph.marquee = graph.svg.append('rect')
    .attr('rx', 2)
    .attr('stroke', '#fff')
    .attr('class', 'selection')
    .attr('x', event.clientX)
    .attr('y', event.clientY)
    .attr('fill', 'none')
    .attr('pointer-events', 'none')
  click.x = event.clientX
  click.y = event.clientY
  dragging = true
}

function onDocumentMouseUp(event) {
  if (!shifting && dragging && click.x != event.clientX && click.y != event.clientY) {
    var a = {'x': click.x, 'y': click.y}
    var b = {'x': event.clientX, 'y': event.clientY}
    var x1 = a.x < b.x ? a.x : b.x
    var x2 = a.x > b.x ? a.x : b.x
    var y1 = a.y < b.y ? a.y : b.y
    var y2 = a.y > b.y ? a.y : b.y
    var nodes = navigation[navigated].context == 'genome' ? graph.genome.nodes : graph.chromosomes.nodes
    for (var i = 0; i < nodes.length; i++) {
      var node = nodes[i]
      var nc = graph.context(node.px, node.py)
      if (nc.x > x1 && nc.x < x2 && nc.y > y1 && nc.y < y2) {
        if (navigation[navigated].context == 'genome' && !node.pinned) linear.svg.append('rect')
          .attr('fill', rainbow(node.chromosome))
          .attr('rx', 5)
          .attr('x', 20 + (segments[node.chromosome][0]) * linear.ratio)
          .attr('y', 70)
          .attr('width', atLeast((segments[node.chromosome][1] - segments[node.chromosome][0]) * linear.ratio, 10))
          .attr('height', 10)
          .attr('class', 'active highlight chr' + node.chromosome + '-all')
        else if (navigation[navigated].context == 'chromosomes' && !node.pinned) {
          linear.svg.append('line')
            .attr('stroke', rainbow(node.chromosome))
            .attr('x1', 20 + node.bin * linear.ratio)
            .attr('x2', 20 + node.bin * linear.ratio)
            .attr('y1', 70 + 0)
            .attr('y2', 70 + 10)
            .attr('class', 'active highlight chr' + node.chromosome + '-' + node.bin)
          var ratio = 1 / (segments[0][1] - segments[0][0]) * ((width / 2) - 70)
          linear.svg.chromosomes[node.chromosome].append('line')
            .attr('stroke', rainbow(node.chromosome))
            .attr('x1', 15 + 20 + (node.bin - segments[node.chromosome][0]) * ratio)
            .attr('x2', 15 + 20 + (node.bin - segments[node.chromosome][0]) * ratio)
            .attr('y1', 0)
            .attr('y2', 10)
            .attr('class', 'active highlight chr' + node.chromosome + '-' + node.bin)
        }
        node.pinned = true
        pinned++
      }
    }
    if (navigation[navigated].context == 'genome') {
      for (var i = 0; i < chromosomes.length; i++) {
        var alphas = new Float32Array(bufferGeometry[i].attributes.alpha.count)
        if (pinned == 0 || chromosomes[i].pinned) for (var a = 0; a < bufferGeometry[i].attributes.alpha.count; a++) alphas[a] = 0.8
        else for (var a = 0; a < bufferGeometry[i].attributes.alpha.count; a++) alphas[a] = 0.2
        bufferGeometry[i].attributes.alpha = new THREE.BufferAttribute(alphas, 1)
      }
    } else if (navigation[navigated].context == 'chromosomes') {
      alphaModelFromGraph()
    }
    if (pinned != 0) d3.selectAll('.node').attr('opacity', function(d){ return d.pinned ? 1 : 0.2 })
    graph.marquee.remove()
    $('#unpin').css('visibility', pinned == 0 ? 'hidden' : 'visible')
  }
  dragging = false
}

function onDocumentKeyDown(event) {
  if (event.shiftKey) shifting = true
}

function onDocumentKeyUp(event) {
  event.preventDefault()
  if (shifting) {
    if (navigation[navigated].context == 'chromosomes') {
      if (pinned == 0) d3.selectAll('.node').attr('opacity', 1)
      else d3.selectAll('.node').attr('opacity', function(d,i){ return d.pinned ? 1 : 0.2 })
      alphaModelFromGraph()
    }
    shifting = false
  }
  if (navigated > 0 && (event.keyCode == 8 || event.keyCode == 46)) {
    navigated--
    navigate(navigated)
  }
  if (event.keyCode != 13) return
  var val = $('#search').val()
  if (val.length == 0 && pinned == 0) {
    navigate(navigation.length - 1)
  } else if (val.length > 0) {
    search(val)
  } else if (pinned > 0) {
    if (navigation[navigated].context == 'genome') {
      var pin = []
      var locus
      for (var i = 0; i < chromosomes.length; i++) {
        if (chromosomes[i].pinned) {
          pin.push(i)
          var center = bufferGeometry[i].boundingSphere.center
          locus = locus == null ? center : locus.add(center)
        }
      }
      locus.divideScalar(pin.length)
      $('#navigation').append("<div class='nav'><span class='icon'>&acd;</span> chromosome " + pin.map(function(c){ return chromosomeName(c) }).toString() + "</div>")
      navigation.push({
        'context': 'chromosomes',
        'node': '1Mb',
        'link': 'distance',
        'chromosomes': pin,
        'locus': locus,
      })
    } else if (navigation[navigated].context == 'chromosomes') {
      var pin = []
      var nin = []
      var locus
      var nodes = graph.chromosomes.nodes
      for (var i = 0; i < nodes.length; i++) {
        var node = nodes[i]
        if (!node.pinned) continue
        var bin = all[node.bin]
        pin.push(bin.bin)
        nin.push(i)
        var geometry = bufferGeometry[bin.chromosome]
        var total = geometry.attributes.position.count
        var segment = segments[bin.chromosome]
        var bins = segment[1] - segment[0]
        var size = parseInt(total / bins)
        var target = (bin.bin - segment[0]) * size * 3
        var center = new THREE.Vector3(
          geometry.attributes.position.array[target],
          geometry.attributes.position.array[target + 1],
          geometry.attributes.position.array[target + 2]
        )
        locus = locus == null ? center : locus.add(center)
      }
      locus.divideScalar(pin.length)
      var string = pin.length == 1 ? pin[0] : pin[0] + "..." + pin[pin.length - 1]
      $('#navigation').append("<div class='nav'><span class='icon'>&there4;</span> bin " + string + "</div>")
      navigation.push({
        'context': 'bins',
        'node': '1Mb',
        'link': 'distance',
        'chromosomes': navigation[navigated].chromosomes,
        'bins': pin,
        'nodes': nin,
        'locus': locus,
      })
    }
    navigate(navigation.length - 1)
  }
}

function alphaModelFromGraph(max) {
  var chr = graph.chromosomes.chr
  for (var i = 0; i < chr.length; i++) {
    var segment = segments[chr[i]]
    var geometry = bufferGeometry[chr[i]]
    var mesh = meshes[chr[i]]
    var total = geometry.attributes.alpha.count
    var bins = segment[1] - segment[0]
    var size = parseInt(total / bins)
    for (var j = segment[0]; j < segment[1]; j++) {
      if (max && all[j].found != null) for (var k = (j - segment[0]) * size; k < (j + 1 - segment[0]) * size; k++) geometry.attributes.alpha.array[k] = atLeast(all[j].found / max * 0.8, 0.3)
      else if (pinned == 0 || all[j].pinned) for (var k = (j - segment[0]) * size; k < (j + 1 - segment[0]) * size; k++) geometry.attributes.alpha.array[k] = 0.8
      else for (var k = (j - segment[0]) * size; k < (j + 1 - segment[0]) * size; k++) geometry.attributes.alpha.array[k] = 0.2
    }
    geometry.attributes.alpha.needsUpdate = true
  }
}

function alphaModel(alpha, visible) {
  for (var i = 0; i < chromosomes.length; i++) {
    if (visible != null && visible.indexOf(i) == -1) meshes[i].visible = false
    else {
      meshes[i].visible = true
      var alphas = new Float32Array(bufferGeometry[i].attributes.alpha.count)
      for (var a = 0; a < bufferGeometry[i].attributes.alpha.count; a++) alphas[a] = alpha
      bufferGeometry[i].attributes.alpha = new THREE.BufferAttribute(alphas, 1)
    }
  }
}

function lookup(chromosome, bins) {
  var prefix = 'https://genome.ucsc.edu/cgi-bin/hgTracks?db=hg38&lastVirtModeType=default&lastVirtModeExtraState=&virtModeType=default&virtMode=0&nonVirtPosition=&position='
  var suffix = '&hgsid=501888851_Vr81OkrPRrUhSo3kt4U7ITltFimU'
  var target = 'chr' + chromosomeName(chromosome) + '%3A' + (bins[0] * 1000000) + '-' + (bins[1] * 1000000)
  window.open(prefix + target + suffix, '_blank')
  window.focus()
}

function distanceToSquared(x1, y1, z1, x2, y2, z2) {
  return Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2) + Math.pow(z2 - z1, 2)
}

function atLeast(value, least) {
  return value > least ? value : least
}

function chromosomeName(index) {
  return (index % 20) == 19 ? "X" : (index % 20) + 1
}

function zoomed() {
  graph.container.selectAll('.node').selectAll('circle,text').attr('transform', 'scale(' + (((zoomToBin + 2) - d3.event.scale) / (zoomToBin + 1)) + ')')
  graph.container.attr('transform', 'translate(' + d3.event.translate + ')scale(' + d3.event.scale + ')')
}

function colorBin(chromosome, bin, color) {
  var total = bufferGeometry[chromosome].attributes.position.count
  var bins = segments[chromosome][1] - segments[chromosome][0]
  var size = parseInt(total / bins)
  for (var v = bin * size; v < (bin + 1) * size; v++) {
    bufferGeometry[chromosome].attributes.color.array[(v * 3)] = color.r / 255
    bufferGeometry[chromosome].attributes.color.array[(v * 3) + 1] = color.g / 255
    bufferGeometry[chromosome].attributes.color.array[(v * 3) + 2] = color.b / 255
  }
  bufferGeometry[chromosome].attributes.color.needsUpdate = true
}

function alphaBin(chromosome, bin, alpha) {
  var total = bufferGeometry[chromosome].attributes.alpha.count
  var bins = segments[chromosome][1] - segments[chromosome][0]
  var size = parseInt(total / bins)
  for (var v = bin * size; v < (bin + 1) * size; v++) {
    bufferGeometry[chromosome].attributes.alpha.array[v] = alpha
  }
  bufferGeometry[chromosome].attributes.alpha.needsUpdate = true
}

function makeAbsoluteContext(element, svgDocument) {
  return function(x,y) {
    var offset = svgDocument.getBoundingClientRect()
    var matrix = element.getScreenCTM()
    return {
      x: (matrix.a * x) + (matrix.c * y) + matrix.e - offset.left,
      y: (matrix.b * x) + (matrix.d * y) + matrix.f - offset.top
    }
  }
}

</script>
</html>
