<html>
<script src='js/three.min.js'></script>
<script src='js/jquery.js'></script>
<script src='js/d3.js'></script>
<script src='js/CanvasRenderer.js'></script>
<script src='js/TrackballControls.js'></script>
<script src='js/Projector.js'></script>
<script src='js/stats.js'></script>
<script src='js/queue.js'></script>
<style>
html, body {
  margin: 0;
  padding: 0;
  font-family: 'Helvetica Neue';
  color: #ffffff;
  text-transform: uppercase;
  font-size: 10px;
}
#graph {
  float: left;
  display: inline-block;
  width: 50%;
  height: 100%;
  background-color: #333;
  margin: 0;
  padding: 0;
}
#model {
  float: left;
  display: inline-block;
  width: 50%;
  height: 100%;
  background-color: #000;
  margin: 0;
  padding: 0;
}
</style>
<body>
  <div id='graph'>
  </div>
  <div id='model'>
  </div>
</body>
<script type='x-shader/x-vertex' id='vertexShader'>
varying vec2 vUv;
varying float noise;
attribute float alpha;
varying float vAlpha;
varying vec3 vColor;
void main() {
  vAlpha = alpha;
  vUv = uv;
  vColor = color;
  gl_PointSize = 1.1;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
</script>
<script type="x-shader/x-fragment" id="fragmentShader">
varying vec2 vUv;
varying float noise;
varying float vAlpha;
varying vec3 vColor;
uniform vec3 colorsa;
void main() {
  gl_FragColor = vec4(vColor, vAlpha);
}
</script>
<script>

var rainbow = d3.scale.category20(),

    cgSize = 300,
    graphCap = 1000,
    graphThreshold = 4,
    mapCap,

    graph = {},
    width = window.innerWidth,
    height = window.innerHeight,

    all = [],
    pdb = [],
    segments = [],
    rap = [],
    chromosomes = [],

    launch = true

var zoom = d3.behavior.zoom()
  .scaleExtent([1, 10])
  .on("zoom", zoomed)

var drag = d3.behavior.drag()
  .origin(function(d) { return d; })
  .on("dragstart", dragstarted)
  .on("drag", dragged)
  .on("dragend", dragended)

var stats = new Stats()
stats.showPanel(1)
document.body.appendChild(stats.dom)

loadPDB('1Mb')

function loadPDB(resolution) {
  all = []
  pdb = []
  segments = []
  rap = []
  chromosomes = []

  var q = queue(1)
  q.defer(d3.text, 'data/Model_' + resolution + '.pdb')
  q.defer(d3.text, 'data/Model_' + resolution + '.pml')
  q.defer(d3.text, 'data/0hr-Xist_' + resolution)
  q.defer(d3.text, 'data/1hr-Xist_' + resolution)
  q.defer(d3.text, 'data/2hr-Xist_' + resolution)
  q.defer(d3.text, 'data/3hr-Xist_' + resolution)
  q.defer(d3.text, 'data/6hr-Xist_' + resolution)
  q.awaitAll(function(error, results){
      segments = results[1].split('\n')
      for (var i = segments.length - 1; i >= 0; i--) {
        var line = segments[i]
        if (line.substring(0, 6) != "select") segments.splice(i, 1)
        else {
          var split = segments[i].split(' ')[2].split('-')
          segments[i] = [parseInt(split[0]), parseInt(split[1])]
        }
      }
      segments.reverse()
      var length = segments.length
      var last = segments[length - 1][1] - 1
      for (var i = 0; i < length; i++) {
        chromosomes.push({
          'chromosome': i,
          'contacts': new Array(resolution == '40kb' ? length * 2 : length)
        })
        if (resolution == '40kb') segments.push([segments[i][0] + last, segments[i][1] + last])
      }
      pdb = results[0].split('\n')
      chromosome = 0
      for (var i = 0; i < pdb.length - 1; i++) {
        if (i > segments[chromosome][1]) chromosome++
        all.push({
          'chromosome': chromosome,
          'bin': i,
          'x3': parseFloat(pdb[i].substring(31,37)),
          'y3': parseFloat(pdb[i].substring(38,45)),
          'z3': parseFloat(pdb[i].substring(46,53)),
          'lamina': parseInt(pdb[i].substring(61,64)),
          'rap': {0: {}, 1: {}, 2: {}, 3: {}, 4: {}}
        })
      }
      for (var d = 0; d < 5; d++) {
        rap = results[d + 2].split('\n')
        for (var i = 0; i < rap.length - 1; i++) {
          var split = rap[i].split('\t')
          var bin = parseInt(split[1]) / (resolution == '1Mb' ? 1000000 : 40000)
          all[bin].rap[d].expected = parseFloat(split[2])
          all[bin].rap[d].actual = parseFloat(split[3])
          all[bin].rap[d].ratio = parseFloat(split[4])
        }
      }
      mapCap = resolution == '1Mb' ? all.length : graphCap
      for (var a = 0; a < mapCap; a++) {
        var binA = all[a]
        binA.contacts = []
        var bins = segments[binA.chromosome][1] - segments[binA.chromosome][0]
        for (var b = 0; b < mapCap; b++) {
          if (a == b) continue
          var binB = all[b]
          var distance = distanceToSquared(binA.x3, binA.y3, binA.z3, binB.x3, binB.y3, binB.z3)
          binA.contacts.push(distance)

          var ic = chromosomes[binA.chromosome].contacts[binB.chromosome]
          chromosomes[binA.chromosome].contacts[binB.chromosome] = ic == null ? 0 : ic + (distance / bins)
        }
      }
      console.log(chromosomes)
      if (launch) init()
      graphChromosomes()
    })
}

function init() {
  launch = false

  graph.svg = d3.select('#graph').append('svg')
    .attr('width', width / 2)
    .attr('height', height)
  graph.container = graph.svg.append('g').call(zoom)
  graph.container.append('rect')
    .attr('width', width / 2)
    .attr('height', height)
    .attr('opacity', 0)
  graph.layer2 = graph.svg.append('g')
  graph.layer1 = graph.layer2.append('g')

  window.addEventListener('resize', onWindowResize, false)

}

function graphChromosomes() {
  var gc = graph.chromosomes = {}
  // gc.force = d3.layout.force()
  //   .size([width / 2, height])
  //   .linkDistance(function(d){ return Math.sqrt(d.distance) / 3 })
  gc.force = d3.layout.force()
    .size([width / 2, height])
    .charge(-300)
    .linkStrength(function(d){ return Math.sqrt(d.distance) / 500 })
  gc.nodes = chromosomes
  gc.links = []
  gc.linked = {}

  for (var i = 0; i < gc.nodes.length; i++) {
    var chromosome = gc.nodes[i]
    for (var j = 0; j < gc.nodes.length; j++) {
      if (chromosome.contacts[j] < 10000 && gc.linked[j] == null) {
        gc.links.push({'source': i, 'target': j, 'distance': chromosome.contacts[j]})
        gc.linked[i] = true
      }
    }
  }

  var node = graph.layer2.selectAll('.node')
    .data(gc.nodes)
  var nodeEnter = node.enter().append('g')
    .attr('class', 'node')
  nodeEnter.append('circle')
    .attr('r', 5)
    .attr('stroke', function(d,i){ return rainbow(i) })
    .attr('stroke-width', 3)
    .attr('fill', '#444')

  var link = graph.layer1.selectAll('.link')
    .data(gc.links).enter().append('line')
    .attr('stroke-width', 2)
    .attr('stroke', '#444')
    .attr('class', 'link')

  gc.force
    .nodes(gc.nodes)
    .links(gc.links)
    .start()
  for (var i = 0; i < Math.pow(gc.nodes.length, 2); i++) gc.force.tick()
  gc.force.stop()
  node
    .attr('transform', function(d,i){ return 'translate(' + d.x + ',' + d.y + ')'})
  link
    .attr('x1', function(d){ return d.source.x })
    .attr('y1', function(d){ return d.source.y })
    .attr('x2', function(d){ return d.target.x })
    .attr('y2', function(d){ return d.target.y })
}

function onWindowResize() {
  width = window.innerWidth
  height = window.innerHeight
  graph.attr('width', width / 2).attr('height', height)
  gc.force.size([width / 2, height])
}

function distanceToSquared(x1, y1, z1, x2, y2, z2) {
  return Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2) + Math.pow(z2 - z1, 2)
}

function zoomed() {
  graph.layer2.attr('transform', 'translate(' + d3.event.translate + ")scale(" + d3.event.scale + ')');
}

function dragstarted(d) {
  d3.event.sourceEvent.stopPropagation();
  d3.select(this).classed('dragging', true);
}

function dragged(d) {
  d3.select(this).attr('cx', d.x = d3.event.x).attr("cy", d.y = d3.event.y);
}

function dragended(d) {
  d3.select(this).classed('dragging', false);
}

</script>
</html>
