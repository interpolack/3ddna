<html>
<script src='js/three.min.js'></script>
<script src='js/jquery.js'></script>
<script src='js/d3.js'></script>
<script src='js/CanvasRenderer.js'></script>
<script src='js/TrackballControls.js'></script>
<script src='js/Projector.js'></script>
<script src='js/stats.js'></script>
<script src='js/queue.js'></script>
<style>
html, body {
  margin: 0;
  padding: 0;
  font-family: 'Helvetica Neue';
  color: #ffffff;
  text-transform: uppercase;
  font-size: 10px;
}
#controls {
  padding: 10px;
  background: none;
  position: absolute;
}
#controls .border {
  border: 2px solid #fff;
  border-radius: 3px;
  width: 10px;
  height: 10px;
  margin: 2px;
  padding: 0;
  float: left;
  cursor: pointer;
}
.panel {
  position: relative;
  border: 1px solid #fff;
  width: 300px;
  height: 300px;
  cursor: pointer;
  background-color: #000;
}
#overlay {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  z-index: 100;
  pointer-events: none;
}
#contact_map {
  width: 100%;
  height: 100%;
}
#contact_graph {
  width: 100%;
  height: 100%;
}
#footer {
  position: absolute;
  bottom: 10px;
  right: 10px;
}
</style>
<body>
  <div id='controls'>
    <form id='resolution'>
      resolution<br>
      <input id='1Mb' type="radio" name="resolution" value="1Mb" checked> 1Mb
      <input id='40kb' type="radio" name="resolution" value="40kb"> 40kb
    </form>
    <form id='coloration'>
      coloration<br>
      <input id='none' type="radio" name="coloration" value="none" checked> none<br>
      <input id='chromosomal' type="radio" name="coloration" value="chromosomal"> chromosomal<br>
      <input id='lamina' type="radio" name="coloration" value="lamina"> lamina association<br>
      <input id='spectral' type="radio" name="coloration" value="spectral"> spectral<br>
      <input id='xist' type="radio" name="coloration" value="xist"> xistence
    </form>
    toggle chromosomes<br>
    <button id='hide_all'>hide all</button>
    <button id='show_all'>show all</button>
    </form>
    <br style='float: clear'>
    <br>
    <br style='float: clear'>
    contact map<br>
    <div class='panel'>
      <svg id='contact_map'></svg>
    </div>
    <br>
    contact graph<br>
    <div class='panel'>
      <svg id='contact_graph'></svg>
    </div>
  </div>
  <div id='footer'>
    hold shift to paint
  </div>
  <div id='3d'></div>
</body>
<script type='x-shader/x-vertex' id='vertexShader'>

varying vec2 vUv;
varying float noise;
attribute float alpha;
varying float vAlpha;
varying vec3 vColor;

void main() {

    vAlpha = alpha;
    vUv = uv;
    vColor = color;
    gl_PointSize = 1.1;
    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

}
</script>

<script type="x-shader/x-fragment" id="fragmentShader">
varying vec2 vUv;
varying float noise;
varying float vAlpha;
varying vec3 vColor;
uniform vec3 colorsa;

void main() {

    gl_FragColor = vec4( vColor, vAlpha );

}
</script>
<script>

var rainbow = d3.scale.category20(),
    coloration = 'none',
    genome,
    chromosomes = {},
    segments,
    arrays,
    bufferGeometry = {},
    spiders = [],
    lines = [],
    labels = [],

    overlay,
    cm = d3.select('#contact_map'),
    cg = d3.select('#contact_graph'),
    force,
    nodes = [],
    links = [],
    linked = {},

    cmSize = 300,
    cmClick,
    cgSize = 300,
    graphCap = 1000,
    graphThreshold = 4,
    mapCap,

    width = window.innerWidth,
    height = window.innerHeight,

    all = [],
    pdb = [],
    segments = [],
    rap = [],

    raycaster,
    mouse,
    clicking = false,
    shifting = false,
    zoom = d3.behavior.zoom(),
    drag = d3.behavior.drag(),

    controls,
    toggle = 0,
    clock = new THREE.Clock(),
    fireflies = [],
    fireflight = [],
    fireIndex = 0,
    fireLines = [],

    launch = true

var stats = new Stats()
stats.showPanel(1)
document.body.appendChild(stats.dom)

loadPDB('1Mb')

function loadPDB(resolution) {
  all = []
  pdb = []
  segments = []
  rap = []

  var q = queue(1)
  q.defer(d3.text, 'data/Model_' + resolution + '.pdb')
  q.defer(d3.text, 'data/Model_' + resolution + '.pml')
  q.defer(d3.text, 'data/0hr-Xist_' + resolution)
  q.defer(d3.text, 'data/1hr-Xist_' + resolution)
  q.defer(d3.text, 'data/2hr-Xist_' + resolution)
  q.defer(d3.text, 'data/3hr-Xist_' + resolution)
  q.defer(d3.text, 'data/6hr-Xist_' + resolution)
  q.awaitAll(function(error, results){
      segments = results[1].split('\n')
      for (var i = segments.length - 1; i >= 0; i--) {
        var line = segments[i]
        if (line.substring(0, 6) != "select") segments.splice(i, 1)
        else {
          var split = segments[i].split(' ')[2].split('-')
          segments[i] = [parseInt(split[0]), parseInt(split[1])]
        }
      }
      segments.reverse()
      if (resolution == '40kb') {
        var last = segments[segments.length - 1][1]
        var length = segments.length
        for (var i = 0; i < length; i++) {
          segments.push([segments[i][0] + last, segments[i][1] + last])
        }
      }
      pdb = results[0].split('\n')
      chromosome = 0
      for (var i = 0; i < pdb.length - 1; i++) {
        if (i > segments[chromosome][1]) chromosome++
        all.push({
          'chromosome': chromosome,
          'bin': i,
          'x3': parseFloat(pdb[i].substring(31,37)),
          'y3': parseFloat(pdb[i].substring(38,45)),
          'z3': parseFloat(pdb[i].substring(46,53)),
          'lamina': parseInt(pdb[i].substring(61,64)),
          'rap': {0: {}, 1: {}, 2: {}, 3: {}, 4: {}}
        })
      }
      for (var d = 0; d < 5; d++) {
        rap = results[d + 2].split('\n')
        for (var i = 0; i < rap.length - 1; i++) {
          var split = rap[i].split('\t')
          var bin = parseInt(split[1]) / (resolution == '1Mb' ? 1000000 : 40000)
          all[bin].rap[d].expected = parseFloat(split[2])
          all[bin].rap[d].actual = parseFloat(split[3])
          all[bin].rap[d].ratio = parseFloat(split[4])
        }
      }
      mapCap = resolution == '1Mb' ? all.length : graphCap
      for (var i = 0; i < mapCap; i++) {
        var bin = all[i]
        bin.contacts = []
        for (var j = 0; j < mapCap; j++) {
          if (i == j) continue
          var bin2 = all[j]
          bin.contacts.push(distanceToSquared(bin.x3, bin.y3, bin.z3, bin2.x3, bin2.y3, bin2.z3))
        }
      }
      if (launch) init()
      showPDB(all, resolution)
      heatCM(all)
    })
}

$('#1Mb').click(function(){ loadPDB('1Mb') })
$('#40kb').click(function(){ loadPDB('40kb')})
$('#hide_all').click(toggleAllChromosomes(false))
$('#show_all').click(toggleAllChromosomes(true))
$('#gene_search').keyup(function(e){
  e.preventDefault()
  var value = $(this).val()
  if (value.length == 0) showAllGenes()
  else showGenes(parseInt(value))
})
$('#contact_map').on('mousemove', function(e){
  hideContacts()
  var mx = e.pageX - $(this).offset().left
  var my = e.pageY - $(this).offset().top
  var x = parseInt(mx / cmSize * segments[segments.length - 1][1])
  var y = parseInt(my / cmSize * segments[segments.length - 1][1])
  var binA = indexToBin(x)
  var binB = indexToBin(y)
  cm.select('.crossX').attr('y1', my).attr('y2', my)
  cm.select('.crossY').attr('x1', mx).attr('x2', mx)
  if (cmClick != null) {
    // cm.select('.selection').attr('width', mx - cmClick[0]).attr('height', my - cmClick[1])
    for (var x = cmClick[2]; x < binA; x++) {
      for (var y = cmClick[3]; y < binB; y++) {
        for (var x2 = cmClick[2]; x2 < binA; x2++) {
          if (x2 == x) continue
          for (var y2 = cmClick[3]; y2 < binB; y2++) {
            if (y2 == y) continue
            showContact(x, y, x2, y2)
          }
        }
      }
    }
  } else showContact(binA[0], binA[1], binB[0], binB[1])
})
$('#contact_map').on('mouseout', function() {
  cmClick = null
  hideContacts()
})
$('#contact_map').on('mousedown', function(e) {
  var mx = e.pageX - $(this).offset().left
  var my = e.pageY - $(this).offset().top
  var x = parseInt(mx / cmSize * segments[segments.length - 1][1])
  var y = parseInt(my / cmSize * segments[segments.length - 1][1])
  var binA = indexToBin(x)
  var binB = indexToBin(y)
  cmClick = [mx, my, binA[1], binB[1]]
  colorBin(binA[0], binA[1], d3.rgb(255, 0, 0))
  colorGraph(binA[0], binA[1])
  cm.append('rect')
    .attr('fill', '#fff')
    .attr('opacity', 0.5)
    .attr('x', mx)
    .attr('y', my)
    .attr('class', 'selection')
})
$('#coloration input').click(function(){
  coloration = $(this).val()
  colorGenes()
})

function showPDB(data, resolution) {

  $('#chromosomes').empty()
  scene.remove(genome)
  genome = new THREE.Object3D()
  chromosomes = []
  d3.selectAll('.label,.pointer').remove()
  spiders = []
  lines = []
  nodes = []
  links = []
  linked = {}
  cg.selectAll('.node,.link').remove()
  cm.selectAll('.heat').remove()
  fireflies = []
  fireflight = []
  fireIndex = 0

  for (var i = 0; i < segments.length; i++) {
    var segment = segments[i]
    var curve = new THREE.CatmullRomCurve3(
      all.slice(segment[0], segment[1]).map(function(values, bin){
        return new THREE.Vector3((values.x3 - 100), (values.y3 - 100), (values.z3 - 100))
      })
    )

    var geometry = new THREE.TubeGeometry(
      curve,  //path
      (segments[i % segments.length][1] - segments[i % segments.length][0]) * (resolution == '1Mb' ? 5 : 2),    //segments
      resolution == '1Mb' ? 0.05 : 0.1,     //radius
      3,     //radiusSegments
      false  //closed
    )
    bufferGeometry[i] = new THREE.BufferGeometry().fromGeometry(geometry)
    var alphas = new Float32Array(bufferGeometry[i].attributes.position.count)
    var colors = new Float32Array(bufferGeometry[i].attributes.position.count * 3)
    var color = d3.rgb(255, 255, 255)
    for (var v = 0; v < bufferGeometry[i].attributes.position.count; v++) {
      alphas[v] = 0.5
      colors[(v * 3)] = color.r / 255
      colors[(v * 3) + 1] = color.g / 255
      colors[(v * 3) + 2] = color.b / 255
    }
    bufferGeometry[i].attributes.alpha = new THREE.BufferAttribute(alphas, 1)
    bufferGeometry[i].attributes.color = new THREE.BufferAttribute(colors, 3)
    material = new THREE.ShaderMaterial({
      vertexShader: document.getElementById('vertexShader').textContent,
      fragmentShader: document.getElementById('fragmentShader').textContent,
      vertexColors: THREE.VertexColors,
      transparent: true,
    })
    chromosomes[i] = new THREE.Mesh(bufferGeometry[i], material)
    chromosomes[i].name = i
    genome.add(chromosomes[i])
    $('#chromosomes').append("<div id='chromosome" + i + "' class='border' style='border-color: " + rainbow(i) + "; background-color:" + rainbow(i) + "'></div>")
    $('#chromosome' + i).click(toggleChromosome(i))
    if (i % 7 == 6) $('#chromosomes').append('<br>')
  }
  scene.add(genome)

  geometry = new THREE.SphereGeometry(0.1, 32, 32)
  material = new THREE.MeshBasicMaterial({ color: 0xff0000 })
  for (var i = 9; i < 40; i++) {
    var firefly = new THREE.Mesh(geometry, material)
    fireflies.push(firefly)
    fireflight.push(null)
    genome.add(firefly)
  }

  camera.position.z = resolution == '1Mb' ? 20 : 60

  makeGraph(all.slice(0, graphCap))

}

function makeGraph(data) {
  nodes = data

  for (var i = 0; i < nodes.length; i++) {
    var bin = nodes[i]
    for (var j = 0; j < nodes.length; j++) {
      if (bin.contacts[j] < graphThreshold && linked[j] == null) {
        links.push({'source': i, 'target': j, 'distance': bin.contacts[j]})
        linked[i] = true
      }
    }
  }

  var link = cg.select('.floor').selectAll('.link')
    .data(links).enter().append('line')
    .attr('stroke', '#666')
    .attr('class', 'link')

  var node = cg.select('.floor').selectAll('.node')
    .data(nodes)
  var nodeEnter = node.enter().append('g')
    .attr('class', function(d,i){ return 'node node' + i })
  nodeEnter.append('circle')
    .attr('fill', function(d){ return d.color == null ? '#fff' : d.color })
    .attr('r', 2)

  force.nodes(nodes).links(links).start()
  for (var i = 0; i < nodes.length * node.length; i++) force.tick()
  force.stop()
  d3.selectAll('.node').attr('transform', function(d){ return 'translate(' + d.x + ',' + d.y + ')' })
  d3.selectAll('.link, .fireLine')
    .attr('x1', function(d){ return d.source.x })
    .attr('y1', function(d){ return d.source.y })
    .attr('x2', function(d){ return d.target.x })
    .attr('y2', function(d){ return d.target.y })
}

function toggleChromosome(i) {
  return function() {
    chromosomes[i].visible = !chromosomes[i].visible
    $('#chromosome' + i).css({ backgroundColor: chromosomes[i].visible ? rainbow(i) : '#000000' })
  }
}

function toggleAllChromosomes(on) {
  return function() {
    for (var i = 0; i < segments.length; i++) {
      chromosomes[i].visible = on
      $('#chromosome' + i).css({ backgroundColor: on ? rainbow(i) : '#000000' })
    }
  }
}

function showAllGenes() {
  for (var i = 0; i < segments.length; i++) {
    var alphas = new Float32Array(bufferGeometry[i].attributes.position.count)
    for (var a = 0; a < bufferGeometry[i].attributes.position.count; a++) alphas[a] = 0.5
    bufferGeometry[i].attributes.alpha = new THREE.BufferAttribute(alphas, 1)
  }
}

function indexToBin(index) {
  for (chromosome = 0; chromosome < segments.length - 1; chromosome++) {
    if (index < segments[chromosome][1]) break
  }
  var bin = index - segments[chromosome][0] - 1
  return [chromosome, bin]
}

function binToIndex(chromosome, bin) {
  return bin + segments[chromosome][0] - 1
}

function colorBin(chromosome, bin, color) {
  var total = bufferGeometry[chromosome].attributes.position.count
  var bins = segments[chromosome][1] - segments[chromosome][0]
  var size = parseInt(total / bins)
  for (var v = bin * size; v < (bin + 1) * size; v++) {
    bufferGeometry[chromosome].attributes.color.array[(v * 3)] = color.r / 255
    bufferGeometry[chromosome].attributes.color.array[(v * 3) + 1] = color.g / 255
    bufferGeometry[chromosome].attributes.color.array[(v * 3) + 2] = color.b / 255
  }
  bufferGeometry[chromosome].attributes.color.needsUpdate = true
}

function showContact(chromosomeA, binA, chromosomeB, binB) {
  var positionA = chromosomes[chromosomeA].geometry.attributes.position.array.slice(binA * 3, (binA * 3) + 3)
  var positionB = chromosomes[chromosomeB].geometry.attributes.position.array.slice(binB * 3, (binB * 3) + 3)
  var fireLine = new THREE.Line(new THREE.Geometry(), new THREE.LineBasicMaterial({ color: 0xff0000, linewidth: 3 }))
  fireLine.geometry.vertices.push(new THREE.Vector3(positionA[0], positionA[1], positionA[2]))
  fireLine.geometry.vertices.push(new THREE.Vector3(positionB[0], positionB[1], positionB[2]))
  genome.add(fireLine)
  fireLines.push(fireLine)
  var nodeA = nodes[binToIndex(chromosomeA, binA)]
  var nodeB = nodes[binToIndex(chromosomeB, binB)]
  if (nodeA != null && nodeB != null) {
    moveGraph(chromosomeA, binA)
    cg.select('.fireLine')
      .datum({'source': nodeA, 'target': nodeB})
      .attr('x1', nodeA.x)
      .attr('y1', nodeA.y)
      .attr('x2', nodeB.x)
      .attr('y2', nodeB.y)
  }
  return distanceToSquared(positionA[0], positionA[1], positionA[2], positionB[0], positionB[1], positionB[2])
}

function hideContacts() {
  for (var i = 0; i < fireLines.length; i++) genome.remove(fireLines[i])
}

function heatCM(data) {
  var res = 10
  var bins = parseInt((segments[segments.length - 1][1] - 1) / res)
  for (var i = 0; i < res; i++) {
    for (var j = 0; j < res; j++) {
      var sum = 0
      for (var x = i * bins; x < (i + 1) * bins; x++) {
        if (x >= mapCap) continue
        for (var y = j * bins; y < (j + 1) * bins; y++) {
          if (y >= mapCap) continue
          sum += all[x].contacts[y]
        }
      }
      cm.append('rect')
        .attr('width', cmSize / res)
        .attr('height', cmSize / res)
        .attr('x', i * cmSize / res)
        .attr('y', j * cmSize / res)
        .attr('fill', d3.rgb(255 - (sum / 200000), 255 - (sum / 200000), 255 - (sum / 200000)))
        .attr('class', 'heat')
    }
  }
  var bins = segments[segments.length - 1][1] - 1
  for (var i = 0; i < segments.length; i++) {
    var start = segments[i][0] / bins * cmSize
    var end = segments[i][1] / bins * cmSize
    cm.append('rect')
      .attr('fill', '#000')
      .attr('stroke', '#666')
      .attr('x', start)
      .attr('y', start)
      .attr('width', end - start)
      .attr('height', end - start)
      .attr('chromosome', function(d,i){ return i })
      .attr('class', 'chromosome')
      .on('click', toggleChromosome(i))
  }
  cm.append('line')
    .attr('stroke', '#fff')
    .attr('x1', 0)
    .attr('x2', cmSize)
    .attr('class', 'crossX')
    .attr('pointer-events', 'none')
  cm.append('line')
    .attr('stroke', '#fff')
    .attr('y1', 0)
    .attr('y2', cmSize)
    .attr('class', 'crossY')
    .attr('pointer-events', 'none')
}

function crossCM(chromosomeA, binA, chromosomeB, binB) {
  var bins = segments[segments.length - 1][1]

  var x = binToIndex(chromosomeA, binA) / bins * cmSize
  cm.select('.crossY').transition().attr('x1', x).attr('x2', x)

  var y = binToIndex(chromosomeB, binB) / bins * cmSize
  cm.select('.crossX').transition().attr('y1', y).attr('y2', y)
}

function colorCM(x, y, contact) {
  cm.append('rect')
    .attr('width', 1)
    .attr('height', 1)
    .attr('x', x)
    .attr('y', y)
    .attr('fill', d3.rgb((400 - contact) / 400 * 255, 0, 0))
}

function moveGraph(chromosome, bin) {
  var nodes = force.nodes()
  var index = binToIndex(chromosome, bin)
  if (index < nodes.length) {
    cg.select('.floor').transition()
      .attr('transform', 'translate(' + (-nodes[index].x + (cgSize / 2)) + ',' + (-nodes[index].y + (cgSize / 2)) + ')')
  }
}

function colorGraph(chromosome, bin) {
  var nodes = force.nodes()
  var index = binToIndex(chromosome, bin)
  if (index < nodes.length) {
    cg.select('.node' + index).select('circle').transition().attr('fill', '#ff0000')
    return
  }
}

function colorGenes() {
  for (var i = 0; i < segments.length; i++) {
    var total = bufferGeometry[i].attributes.position.count
    var colors = new Float32Array(total * 3)
    var alphas = new Float32Array(total)
    var color
    var bins = segments[i][1] - segments[i][0]
    var divisor = total / bins
    if (coloration == 'none') color = d3.rgb(255, 255, 255)
    else color = d3.rgb(rainbow(i))
    for (var v = 0; v < total; v++) {
      var bin = segments[i][0] + Math.floor(v / divisor)
      if (coloration == 'lamina') color = all[bin].lamina ? d3.rgb(0,255,100) : d3.rgb(255,0,0)
      else if (coloration == 'spectral') color = d3.rgb(
        v / total * 255,
        (total - v) / total * 255,
        (total - v) / total * 255
      )
      else if (coloration == 'xist') {
        var ratio = all[bin].rap[4].ratio
        color = d3.rgb(
          ratio < 1 ? 200 : (1 - ratio) * 255,
          (ratio / 20) * 255,
          (ratio / 20) * 100
        )
      }
      colors[(v * 3)] = color.r / 255
      colors[(v * 3) + 1] = color.g / 255
      colors[(v * 3) + 2] = color.b / 255
      alphas[v] = 0.5
    }
    bufferGeometry[i].attributes.color = new THREE.BufferAttribute(colors, 3)
    bufferGeometry[i].attributes.alpha = new THREE.BufferAttribute(alphas, 1)
  }
  if (coloration == 'none') {
    cm.selectAll('.chromosome').attr('stroke', '#666')
    cg.selectAll('.node').select('circle').attr('fill', '#fff')
  } else if (coloration == 'chromosomal') {
    cm.selectAll('.chromosome').attr('stroke', function(d,i){ return rainbow(i)})
    cg.selectAll('.node').select('circle')
      .attr('fill', function(d){ return rainbow(d.chromosome) })
  } else if (coloration == 'lamina') {
    cm.selectAll('.chromosome').attr('stroke', '#666')
    cg.selectAll('.node').select('circle')
      .attr('fill', function(d){ return d.lamina ? '#0f0' : '#f00' })
  } else if (coloration == 'spectral') {
    cm.selectAll('.chromosome').attr('stroke', '#666')
    cg.selectAll('.node').select('circle')
      .attr('fill', function(d,i){
        var ratio = (i - segments[d.chromosome][0] - 1) / (segments[d.chromosome][1] - segments[d.chromosome][0])
        return d3.rgb(ratio * 255, (1 - ratio) * 255, (1 - ratio) * 255)
      })
  } else if (coloration == 'xist') {
    cm.selectAll('.chromosome').attr('stroke', '#666')
    cg.selectAll('.node').select('circle')
      .attr('fill', function(d){ return d.rap[0].ratio > 1 ? '#0f0' : '#f00' })
  }
}

function init() {

  launch = false

  scene = new THREE.Scene()
  camera = new THREE.PerspectiveCamera(75, width / height, 1, 20000)
  camera.position.z = 3000
  scene.add(camera)

  // var light = new THREE.PointLight(0xffffff, 5, 2000)
  // light.position.set(0,0,2000)
  // scene.add(light)

  raycaster = new THREE.Raycaster()
  mouse = new THREE.Vector2()

  renderer = new THREE.WebGLRenderer()
  renderer.setSize(width, height)
  document.body.appendChild(renderer.domElement)

  controls = new THREE.TrackballControls(camera, renderer.domElement)
  // controls.enableDamping = true
  // // controls.dampingFactor = 0.9
  // controls.enableZoom = true

  window.addEventListener('resize', onWindowResize, false)
  document.addEventListener('mousedown', onDocumentMouseDown, false)
  document.addEventListener('mouseup', onDocumentMouseUp, false)
  document.addEventListener('keydown', onDocumentKeyDown, false)
  document.addEventListener('keyup', onDocumentKeyUp, false)
  document.addEventListener('mousemove', onDocumentMouseMove, false)

  overlay = d3.select('body').append('svg')
    .attr('width', width)
    .attr('height', height)
    .attr('id', 'overlay')
  layer1 = overlay.append('g').attr('id', 'layer1')

  cg.append('g').attr('class', 'floor').call(drag)
    .append('line').attr('class', 'fireLine').attr('stroke', '#ff0000')
      .datum({'source': 0, 'target': 0})

  force = d3.layout.force()
    .size([cgSize, cgSize])
    // .linkStrength(10.0)
    .linkDistance(function(d){ return d.distance })
    .charge(-10)
    // .gravity(0.3)

  animate()

}

function animate() {
  requestAnimationFrame(animate)
  stats.begin()
  controls.update()
  render()
  stats.end()
}

function render() {

  for (var i = 0; i < lines.length; i++) {
    line = lines[i]
    lines[i].line
      .attr('x2', toScreenPosition(lines[i].v).x)
      .attr('y2', toScreenPosition(lines[i].v).y)
  }
  // if (genome != null) {
  //   genome.rotation.x += 0.001
  //   genome.rotation.y += 0.001
  //   genome.rotation.z += 0.001
  // }

  for (var i = 0; i < fireflies.length; i++) {
    var firefly = fireflies[i]
    firefly.scale.multiplyScalar(0.98)
    firefly.scale.clampScalar(0.01, 1)
  }

  toggle += clock.getDelta()

  renderer.render(scene, camera)
}

function toScreenPosition(obj) {
    var vector = new THREE.Vector3()

    var widthHalf = 0.5*renderer.context.canvas.width
    var heightHalf = 0.5*renderer.context.canvas.height

    obj.updateMatrixWorld()
    vector.setFromMatrixPosition(obj.matrixWorld)
    vector.project(camera)

    vector.x = ( vector.x * widthHalf ) + widthHalf
    vector.y = - ( vector.y * heightHalf ) + heightHalf

    return {
        x: vector.x,
        y: vector.y
    }
}

function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight
  camera.updateProjectionMatrix()
  renderer.setSize(window.innerWidth, window.innerHeight)
}

function onDocumentMouseDown() {
  clicking = true
}

function onDocumentMouseUp() {
  clicking = false
  hideContacts()
}

function onDocumentKeyDown(event) {
  if (event.shiftKey) shifting = true
}

function onDocumentKeyUp(event) {
  if (shifting) shifting = false
}

function onDocumentMouseMove(event) {
  event.preventDefault()
  mouse.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1
  mouse.y = -(event.clientY / renderer.domElement.clientHeight) * 2 + 1

  raycaster.setFromCamera(mouse, camera)
  var intersections = raycaster.intersectObjects(genome.children)
  var intersection = ( intersections.length ) > 0 ? intersections[ 0 ] : null

  if (toggle > 0.02 && intersection !== null && intersection.object.visible && intersection.object.name !== "") {
    var chromosome = intersection.object.name
    var faceIndex = intersection.faceIndex
    var total = bufferGeometry[chromosome].attributes.alpha.count
    var bins = segments[chromosome][1] - segments[chromosome][0]
    var bin = parseInt(faceIndex / total * bins)
    crossCM(chromosome, bin, chromosome, bin)
    moveGraph(chromosome, bin)
    if (shifting) {
      colorBin(chromosome, bin, d3.rgb(255,0,0))
      colorGraph(chromosome, bin)
      fireflight[fireIndex] = intersection.object
      fireflies[fireIndex].position.copy(intersection.point)
      fireflies[fireIndex].scale.set(1, 1, 1)
      fireIndex = (fireIndex + 1) % fireflies.length
      toggle = 0
    }
  }
}

function distanceToSquared(x1, y1, z1, x2, y2, z2) {
  return Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2) + Math.pow(z2 - z1, 2)
}

</script>
</html>
