<html>
<script src='js/three.min.js'></script>
<script src='js/jquery.js'></script>
<script src='js/d3.js'></script>
<script src='js/CanvasRenderer.js'></script>
<script src='js/Projector.js'></script>
<script src='js/stats.js'></script>
<script src='js/queue.js'></script>
<style>
html, body {
  margin: 0;
  padding: 0;
  font-family: 'Helvetica Neue';
  color: #ffffff;
  text-transform: uppercase;
  font-size: 10px;
}
#controls {
  padding: 10px;
  background: none;
  position: absolute;
}
#controls .border {
  border: 2px solid #fff;
  border-radius: 3px;
  width: 10px;
  height: 10px;
  margin: 2px;
  padding: 0;
  float: left;
  cursor: pointer;
}
#gene_search {
  border-radius: 5px;
  background: none;
  border: 1px solid #fff;
  color: #fff;
  margin-top: 3px;
  padding: 3px;
}
#gene_track {
  position: relative;
  border-radius: 5px;
  border: 1px solid #fff;
  width: 50px;
  height: 200px;
  cursor: pointer;
}
#overlay {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  z-index: 100;
  pointer-events: none;
}
</style>
<body>
  <div id='controls'>
    <form id='resolution'>
      resolution<br>
      <input id='1Mb' type="radio" name="resolution" value="1Mb" checked> 1Mb
      <input id='40kb' type="radio" name="resolution" value="40kb"> 40kb
    </form>
    <form id='coloration'>
      coloration<br>
      <input id='none' type="radio" name="coloration" value="none" checked> none<br>
      <input id='chromosomal' type="radio" name="coloration" value="chromosomal"> chromosomal<br>
      <input id='lamina' type="radio" name="coloration" value="lamina"> lamina association<br>
      <input id='spectral' type="radio" name="coloration" value="spectral"> spectral<br>
      <input id='xist' type="radio" name="coloration" value="xist"> xistence
    </form>
    toggle chromosomes<br>
    <button id='hide_all'>hide all</button>
    <button id='show_all'>show all</button>
    <form id='chromosomes'>
    </form>
    <br style='float: clear'>
    <br>
    <br>
    <br>
    gene search<br>
    <input id='gene_search' type='text'><br>
    <br style='float: clear'>
    gene track<br>
    <div id='gene_track'></div>
  </div>
  <div id='3d'></div>
</body>
<script type='x-shader/x-vertex' id='vertexShader'>

varying vec2 vUv;
varying float noise;
attribute float alpha;
varying float vAlpha;
varying vec3 vColor;

void main() {

    vAlpha = alpha;
    vUv = uv;
    vColor = color;
    gl_PointSize = 1.0;
    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

}
</script>

<script type="x-shader/x-fragment" id="fragmentShader">
varying vec2 vUv;
varying float noise;
varying float vAlpha;
varying vec3 vColor;
uniform vec3 colorsa;

void main() {

    gl_FragColor = vec4( vColor, vAlpha );

}
</script>
<script>

var rainbow = d3.scale.category20(),
    coloration = 'none',
    genome,
    chromosomes = {},
    segments,
    arrays,
    bufferGeometry = {},
    spiders = [],
    lines = [],
    labels = [],
    overlay,
    width = window.innerWidth,
    height = window.innerHeight,

    all = [],
    pdb,
    segments

var stats = new Stats()
stats.showPanel(1)
document.body.appendChild(stats.dom)

function loadPDB(resolution) {var q = queue(1)
q.defer(d3.text, 'data/Model_' + resolution + '.pdb')
q.defer(d3.text, 'data/Model_' + resolution + '.pml')
q.defer(d3.text, 'data/0hr-Xist_' + resolution)
q.defer(d3.text, 'data/1hr-Xist_' + resolution)
q.defer(d3.text, 'data/2hr-Xist_' + resolution)
q.defer(d3.text, 'data/3hr-Xist_' + resolution)
q.defer(d3.text, 'data/6hr-Xist_' + resolution)
q.awaitAll(function(error, results){
    segments = results[1].split('\n')
    for (var i = segments.length - 1; i >= 0; i--) {
      var line = segments[i]
      if (line.substring(0, 6) != "select") segments.splice(i, 1)
      else {
        var split = segments[i].split(' ')[2].split('-')
        segments[i] = [parseInt(split[0]), parseInt(split[1])]
      }
    }
    segments.reverse()
    if (resolution == '40kb') {
      var last = segments[segments.length - 1][1]
      var length = segments.length
      for (var i = 0; i < length; i++) {
        segments.push([segments[i][0] + last, segments[i][1] + last])
      }
    }
    pdb = results[0].split('\n')
    chromosome = 0
    for (var i = 0; i < pdb.length - 1; i++) {
      if (i > segments[chromosome][1]) chromosome++
      all.push({
        'chromosome': chromosome,
        'bin': i,
        'x3': parseFloat(pdb[i].substring(31,37)),
        'y3': parseFloat(pdb[i].substring(38,45)),
        'z3': parseFloat(pdb[i].substring(46,53)),
        'lamina': parseInt(pdb[i].substring(61,64)),
        'rap': {0: {}, 1: {}, 2: {}, 3: {}, 4: {}}
      })
    }
    for (var d = 0; d < 5; d++) {
      rap = results[d + 2].split('\n')
      for (var i = 0; i < rap.length - 1; i++) {
        var split = rap[i].split('\t')
        var bin = parseInt(split[1]) / (resolution == '1Mb' ? 1000000 : 40000)
        all[bin].rap[d].expected = parseFloat(split[2])
        all[bin].rap[d].actual = parseFloat(split[3])
        all[bin].rap[d].ratio = parseFloat(split[4])
      }
    }
    showPDB(all, resolution)
  })
  // $.get('data/Model_' + resolution + '.pdb', function(data) {
  //   var data = data.split('\n')
  //   for (var i = 0; i < data.length - 1; i++) {
  //     data[i] = {'x': parseFloat(data[i].substring(31,37)), 'y': parseFloat(data[i].substring(38,45)), 'z': parseFloat(data[i].substring(46,53)), 'lamina': data[i].substring(61,64) == '1.0'}
  //   }
  //   $.get('data/0hr-Xist_' + resolution, function(xist) {
  //     var xist = xist.split('\n')
  //     for (var i = 0; i < xist.length - 1; i++) {
  //       var split = xist[i].split('\t')
  //       data[i].xist = parseFloat(split[4])
  //     }
  //     showPDB(data, resolution)
  //   })
  // })
}

$('#1Mb').click(function(){ loadPDB('1Mb') })
$('#40kb').click(function(){ loadPDB('40kb')})
$('#hide_all').click(toggleAllChromosomes(false))
$('#show_all').click(toggleAllChromosomes(true))
$('#gene_search').keyup(function(e){
  e.preventDefault()
  var value = $(this).val()
  if (value.length == 0) showAllGenes()
  else showGenes(parseInt(value))
})
$('#gene_track').on('mousemove', function(e){
  var index = e.pageY - $(this).offset().top
  showGenes(index)
})
$('#coloration input').click(function(){
  coloration = $(this).val()
  colorGenes()
})


init()
loadPDB('1Mb')
// showPDB([], 'sim')

function showPDB(data, resolution) {

  $('#chromosomes').empty()
  scene.remove(genome)
  d3.selectAll('.label,.pointer').remove()
  spiders = []
  lines = []

  genome = new THREE.Object3D()
  for (var i = 0; i < segments.length; i++) {
    var segment = segments[i]
    var curve = new THREE.CatmullRomCurve3(
      all.slice(segment[0], segment[1]).map(function(values, bin){
        return new THREE.Vector3((values.x3 - 100) * 100, (values.y3 - 100) * 100, (values.z3 - 100) * 100)
      })
    )

    var geometry = new THREE.TubeGeometry(
      curve,  //path
      (segments[i % segments.length][1] - segments[i % segments.length][0]) * (resolution == '1Mb' ? 5 : 1),    //segments
      resolution == '1Mb' ? 4 : 8,     //radius
      1,     //radiusSegments
      false  //closed
    )
    bufferGeometry[i] = new THREE.BufferGeometry().fromGeometry(geometry)
    var alphas = new Float32Array(bufferGeometry[i].attributes.position.count)
    var colors = new Float32Array(bufferGeometry[i].attributes.position.count * 3)
    var color = d3.rgb(255, 178, 5)
    for (var v = 0; v < bufferGeometry[i].attributes.position.count; v++) {
      alphas[v] = 0.5
      colors[(v * 3)] = color.r / 255
      colors[(v * 3) + 1] = color.g / 255
      colors[(v * 3) + 2] = color.b / 255
    }
    bufferGeometry[i].attributes.alpha = new THREE.BufferAttribute(alphas, 1)
    bufferGeometry[i].attributes.color = new THREE.BufferAttribute(colors, 3)
    material = new THREE.ShaderMaterial({
      vertexShader: document.getElementById('vertexShader').textContent,
      fragmentShader: document.getElementById('fragmentShader').textContent,
      vertexColors: THREE.VertexColors,
      transparent: true,
    })
    chromosomes[i] = new THREE.Points(bufferGeometry[i], material)
    genome.add(chromosomes[i])
    $('#chromosomes').append("<div id='chromosome" + i + "' class='border' style='border-color: " + rainbow(i) + "; background-color:" + rainbow(i) + "'></div>")
    $('#chromosome' + i).click(toggleChromosome(i))
    if (i % 7 == 6) $('#chromosomes').append('<br>')
  }
  scene.add(genome)

  camera.position.z = 3000

}

function toggleChromosome(i) {
  return function() {
    chromosomes[i].visible = !chromosomes[i].visible
    $('#chromosome' + i).css({ backgroundColor: chromosomes[i].visible ? rainbow(i) : '#000000' })
  }
}

function toggleAllChromosomes(on) {
  return function() {
    for (var i = 0; i < segments.length; i++) {
      chromosomes[i].visible = on
      $('#chromosome' + i).css({ backgroundColor: on ? rainbow(i) : '#000000' })
    }
  }
}

function showAllGenes() {
  for (var i = 0; i < segments.length; i++) {
    var alphas = new Float32Array(bufferGeometry[i].attributes.position.count)
    for (var a = 0; a < bufferGeometry[i].attributes.position.count; a++) alphas[a] = 0.5
    bufferGeometry[i].attributes.alpha = new THREE.BufferAttribute(alphas, 1)
  }
}

function showGenes(bin) {
  for (var i = 0; i < segments.length; i++) {
    var alphas = new Float32Array(bufferGeometry[i].attributes.position.count)
    for (var a = 0; a < bufferGeometry[i].attributes.position.count; a++) {
      if (a > bin * 30 * 5 && a < (bin + 1) * 30 * 5) alphas[a] = 1
      else alphas[a] = 0.05
    }
    bufferGeometry[i].attributes.alpha = new THREE.BufferAttribute(alphas, 1)
  }
}

function colorGenes() {
  for (var i = 0; i < segments.length; i++) {
    var total = bufferGeometry[i].attributes.position.count
    var colors = new Float32Array(total * 3)
    var alphas = new Float32Array(total)
    var color
    if (coloration == 'none') color = d3.rgb(255, 178, 5)
    else color = d3.rgb(rainbow(i))
    for (var bin = 0; bin < all.length; bin++) {
      if (coloration == 'lamina') color = all[bin].lamina ? d3.rgb(0,255,100) : d3.rgb(255,0,0)
      else if (coloration == 'spectral') color = d3.rgb(
        bin / all.length * 255,
        (all.length - bin) / all.length * 255,
        (all.length - bin) / all.length * 255
      )
      else if (coloration == 'xist') color = d3.rgb(
        all[bin].rap[3].ratio < 1 ? 200 : (1 - all[bin].rap[3].ratio) * 255,
        (all[bin].rap[3].ratio - 1) * 255,
        (all[bin].rap[3].ratio - 1) * 100
      )
      colors[(bin * 3)] = color.r / 255
      colors[(bin * 3) + 1] = color.g / 255
      colors[(bin * 3) + 2] = color.b / 255
      alphas[bin] = 0.5
    }
    bufferGeometry[i].attributes.color = new THREE.BufferAttribute(colors, 3)
    bufferGeometry[i].attributes.alpha = new THREE.BufferAttribute(alphas, 1)
  }
}

function addSpider(chr, body, legs) {
  var spider = new THREE.Object3D()
  // var positions = genome.children[0].geometry.attributes.position.array
  var positions = arrays[chr].position
  geometry = new THREE.BoxGeometry(30, 30, 30, 2, 2, 2)
  bodyMesh = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({color: 0xff0000}))
  bodyMesh = new THREE.EdgesHelper(bodyMesh, 0xff0606)
  bodyMesh.position.set(positions[body].x, positions[body].y, positions[body].z)
  bodyMesh.matrixAutoUpdate = true
  spider.add(bodyMesh)
  for (var i = 0; i < legs.length; i++) {
    legMesh = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({color: 0xffffff}))
    legMesh = new THREE.EdgesHelper(legMesh, 0xfffffff)
    legMesh.matrixAutoUpdate = true
    legMesh.position.set(positions[legs[i]].x, positions[legs[i]].y, positions[legs[i]].z)
    spider.add(legMesh)
    var lineGeometry = new THREE.Geometry()
    lineGeometry.vertices.push(bodyMesh.position)
    lineGeometry.vertices.push(legMesh.position)
    line = new THREE.Line(lineGeometry, new THREE.LineBasicMaterial({color: 0xffffff, opacity: 0.5}))
    spider.add(line)
  }
  spider.chromosome = chr
  spiders.push(spider)
  genome.add(spiders[spiders.length - 1])
  var label = overlay.append('text')
    .text("| 0" + spiders.length)
    .attr('x', width / 2 + 100)
    .attr('y', height / 2 - 200 + (spiders.length * 50))
    .attr('fill', '#ffffff')
    .attr('class', 'label')
  labels.push(label)
  var line = overlay.append('line')
    .attr('x1', width / 2 - 5 + 100)
    .attr('y1',  height / 2 - 200 + (spiders.length * 50) - 5)
    .attr('x2', 0)
    .attr('y2', 0)
    .attr('opacity', 0.5)
    .attr('stroke', '#fff')
    .attr('class', 'pointer')
  lines.push({
    'line': line,
    'v': spiders[spiders.length - 1].children[0],
  })
}

function makeGraph() {
  var nodes = []
  var links = []
  var wires = []
  for (var s = 0; s < spiders.length; s++) {
    var spider = spiders[s]
    var head = spider.children[0]
    var h = nodes.length
    var previous = head
    nodes.push({'type': 0, 'child': spider.children[0], 'attributes': arrays[spider.chromosome].attributes[0]})
    wires.push({'source': wires.length, 'target': nodes.length - 1})
    for (var c = 1; c < spider.children.length; c++) {
      var child = spider.children[c]
      if (child.type == 'Line') continue
      nodes.push({'type': 1, 'child': spider.children[c], 'attributes': arrays[spider.chromosome].attributes[c]})
      // links.push({'type': 0, 'source': h, 'target': nodes.length - 1, 'distance': head.position.distanceToSquared(child.position)})
      links.push({'type': 1, 'source': nodes.length - 2, 'target': nodes.length - 1, 'distance': previous.position.distanceToSquared(child.position)})
      previous = child
    }
    for (var x = 0; x < nodes.length; x++) {
      for (var y = 0; y < 6; y++) {
        if (x < nodes.length - y) links.push({'type': 0, 'source': x, 'target': x + y, 'distance': nodes[x].child.position.distanceToSquared(nodes[x + y].child.position)})
        if (x > y) links.push({'type': 0, 'source': x, 'target': x - y, 'distance': nodes[x].child.position.distanceToSquared(nodes[x - y].child.position)})
      }
    }
    links.push({'type': 2, 'source': 0, 'target': nodes.length - 1, 'distance': 20000 })
  }
  var force = d3.layout.force()
    .nodes(nodes)
    .links(links)
    .size([width / 2, height])
    .linkStrength(10.0)
    .linkDistance(function(d){ return d.distance / 2000.0 })
    .charge(-500)
    .gravity(0.3)
  var node = d3.select('#overlay').selectAll('.node')
    .data(nodes)
  var nodeEnter = node.enter().append('g')
    .attr('class', 'node')
  nodeEnter.append('rect')
    .attr('width', 5)
    .attr('height', 5)
    .attr('x', -2.5)
    .attr('y', -2.5)
    .attr('fill', 'none')
    .attr('stroke', function(d){ return d.type == 0 ? '#ff0000' : '#fff' })
  var link = d3.select('#layer1').selectAll('.link')
    .data(links).enter().append('line')
    .attr('opacity', function(d){ return d.type == 0 ? 0.1 : 1.0 })
    .attr('stroke', function(d){
      switch (d.type) {
        case 0: return '#fff'
        case 1: return '#fb0'
        case 2: return '#000'
      }
    })
    .attr('class', 'link')
  var wire = d3.select('#overlay').selectAll('.wire')
    .data(wires).enter().append('line')
    .attr('stroke', '#fff')
    .attr('opacity', 0.5)
    .attr('class', 'wire')
  force.on('tick', function(){
    d3.selectAll('.node').attr('transform', function(d){ return 'translate(' + (d.x + width/2) + ',' + d.y + ')' })
    d3.selectAll('.link')
      .attr('x1', function(d){ return d.source.x + width/2 })
      .attr('x2', function(d){ return d.target.x + width/2 })
      .attr('y1', function(d){ return d.source.y })
      .attr('y2', function(d){ return d.target.y })
    d3.selectAll('.wire')
      .attr('x1', function(d){ return labels[d.source].attr('x') })
      .attr('y1', function(d){ return labels[d.source].attr('y') - 5 })
      .attr('x2', function(d){ return nodes[d.target].x + width/2 })
      .attr('y2', function(d){ return nodes[d.target].y })
  }).start()
}

function init() {

  scene = new THREE.Scene()
  camera = new THREE.PerspectiveCamera(75, width / height, 1, 20000)
  camera.position.z = 3000
  scene.add(camera)

  // var light = new THREE.PointLight(0xffffff, 5, 2000)
  // light.position.set(0,0,2000)
  // scene.add(light)

  renderer = new THREE.WebGLRenderer()
  renderer.setSize(width, height)
  document.body.appendChild(renderer.domElement)

  overlay = d3.select('body').append('svg')
    .attr('width', width)
    .attr('height', height)
    .attr('id', 'overlay')
  layer1 = overlay.append('g').attr('id', 'layer1')

  animate()

}

function animate() {
  requestAnimationFrame(animate)
  stats.begin()
  render()
  stats.end()
}

function render() {
  for (var i = 0; i < lines.length; i++) {
    line = lines[i]
    lines[i].line
      .attr('x2', toScreenPosition(lines[i].v).x)
      .attr('y2', toScreenPosition(lines[i].v).y)
  }
  if (genome != null) {
    genome.rotation.x += 0.001
    genome.rotation.y += 0.001
    genome.rotation.z += 0.001
  }
  renderer.render(scene, camera)
}

function toScreenPosition(obj) {
    var vector = new THREE.Vector3()

    var widthHalf = 0.5*renderer.context.canvas.width
    var heightHalf = 0.5*renderer.context.canvas.height

    obj.updateMatrixWorld()
    vector.setFromMatrixPosition(obj.matrixWorld)
    vector.project(camera)

    vector.x = ( vector.x * widthHalf ) + widthHalf
    vector.y = - ( vector.y * heightHalf ) + heightHalf

    return {
        x: vector.x,
        y: vector.y
    }

}

</script>
</html>
