<html>
<script src='js/three.min.js'></script>
<script src='js/jquery.js'></script>
<script src='js/d3.js'></script>
<script src='js/CanvasRenderer.js'></script>
<script src='js/TrackballControls.js'></script>
<script src='js/Projector.js'></script>
<script src='js/stats.js'></script>
<script src='js/queue.js'></script>
<style>
html, body {
  margin: 0;
  padding: 0;
  font-family: 'Helvetica Neue';
  color: #ffffff;
  text-transform: uppercase;
  font-size: 10px;
  background-color: #000;
}
#controls {
  position: absolute;
  top: 0;
  left: 0;
  padding: 10px;
}
  span {
    font-size: 20px;
  }
  #controls select {
    width: 100px;
  }
  #search {
    border-radius: 3px;
    height: 18px;
    width: 100px;
    border: 1px solid #666;
    color: #000;
    padding-left: 8px;
  }
#navigation {
  position: absolute;
  top: 0;
  left: 0;
  padding: 10px;
}
  #navigation .nav {
    margin: 0;
    cursor: pointer;
    margin-bottom: -5px;
  }
  #navigation .nav.inactive {
    color: #666;
  }
  #navigation .nav:hover {
    color: #00c4f4;
  }
#left {
  float: left;
  display: inline-block;
  width: 50%;
  height: 100%;
  background-color: #333;
  margin: 0;
  padding: 0;
}
#graph {
  width: 100%;
  height: 100%;
  border-bottom: 1px solid #000;
  overflow: hidden;
}
#matrix {
  width: 200px;
  height: 200px;
  overflow: hidden;
  position: absolute;
  bottom: 0;
  left: 0;
}
#model {
  position: relative;
  float: left;
  display: inline-block;
  width: 50%;
  height: 100%;
  background-color: #000;
  padding: 0;
  overflow: hidden;
}
.node {
  cursor: pointer;
}
.link {
  cursor: pointer;
}
</style>
<body>
  <div id='controls'>
    <span>&ocir; </span> <select id='node'>
      <option value='chromosome'>chromosome</option>
      <option value='1Mb'>1Mb</option>
    </select><br>
    <span>&origof; </span> <select id='link'>
      <option value='weighted'>distance/bin</option>
      <option value='distance'>distance</option>
    </select><br>
    <span>&xopf; </span>&nbsp;<input id='search' type='text'></input>
    <br>
  </div>
  <div id='matrix'>
  </div>
  <div id='left'>
    <div id='graph'>
    </div>
  </div>
  <div id='model'>
    <div id='navigation'>
      <div class='nav'><span>&oast;</span> genome</div>
    </div>
  </div>
</body>
<script type='x-shader/x-vertex' id='vertexShader'>
varying vec2 vUv;
varying float noise;
attribute float alpha;
varying float vAlpha;
varying vec3 vColor;
void main() {
  vAlpha = alpha;
  vUv = uv;
  vColor = color;
  gl_PointSize = 1.1;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
</script>
<script type="x-shader/x-fragment" id="fragmentShader">
varying vec2 vUv;
varying float noise;
varying float vAlpha;
varying vec3 vColor;
uniform vec3 colorsa;
void main() {
  gl_FragColor = vec4(vColor, vAlpha);
}
</script>
<script>

var rainbow = d3.scale.category20(),

    resolution = '1Mb',
    cgSize = 300,
    graphCap = 1000,
    graphThreshold = 4,
    mapCap,

    graph = {},
    width = window.innerWidth,
    initialWidth = window.innerWidth,
    height = window.innerHeight,
    initialHeight = window.innerHeight,

    all = [],
    pdb = [],
    segments = [],
    rap = [],
    chromosomes = [],
    meshes = [],
    bufferGeometry = [],
    loaded = {},

    pinned = 0,
    navigation = [],
    navigated = 0,

    scene,
    camera,
    renderer,
    controls,
    genome,

    mouse = {'x': 0, 'y': 0},

    zoomToBin = 8,
    graphed = false,
    launch = true

var zoom = d3.behavior.zoom()
  .scaleExtent([1, 20])
  .on("zoom", zoomed)

var drag = d3.behavior.drag()
  .origin(function(d) { return d; })
  .on("dragstart", dragstarted)
  .on("drag", dragged)
  .on("dragend", dragended)

var stats = new Stats()
stats.showPanel(1)
document.body.appendChild(stats.dom)

loadPDB('1Mb')

function loadPDB(resolution) {
  all = []
  pdb = []
  segments = []
  rap = []
  chromosomes = []

  var q = queue(1)
  q.defer(d3.text, 'data/Model_' + resolution + '.pdb')
  q.defer(d3.text, 'data/Model_' + resolution + '.pml')
  q.defer(d3.text, 'data/0hr-Xist_' + resolution)
  q.defer(d3.text, 'data/1hr-Xist_' + resolution)
  q.defer(d3.text, 'data/2hr-Xist_' + resolution)
  q.defer(d3.text, 'data/3hr-Xist_' + resolution)
  q.defer(d3.text, 'data/6hr-Xist_' + resolution)
  q.awaitAll(function(error, results){
      segments = results[1].split('\n')
      for (var i = segments.length - 1; i >= 0; i--) {
        var line = segments[i]
        if (line.substring(0, 6) != "select") segments.splice(i, 1)
        else {
          var split = segments[i].split(' ')[2].split('-')
          segments[i] = [parseInt(split[0]) - 1, parseInt(split[1]) - 1]
        }
      }
      segments.reverse()
      var length = segments.length
      var last = segments[length - 1][1]
      for (var i = 0; i < length; i++) {
        chromosomes.push({
          'chromosome': i,
          'contacts': new Array(resolution == '40kb' ? length * 2 : length)
        })
        if (resolution == '40kb') segments.push([segments[i][0] + last, segments[i][1] + last])
      }
      pdb = results[0].split('\n')
      chromosome = 0
      for (var i = 0; i < pdb.length - 1; i++) {
        if (i > segments[chromosome][1]) chromosome++
        all.push({
          'chromosome': chromosome,
          'bin': i,
          'x3': parseFloat(pdb[i].substring(31,37)),
          'y3': parseFloat(pdb[i].substring(38,45)),
          'z3': parseFloat(pdb[i].substring(46,53)),
          'lamina': parseInt(pdb[i].substring(61,64)),
          'rap0': 0.0,
          'rap1': 0.0,
          'rap2': 0.0,
          'rap3': 0.0,
          'rap4': 0.0,
        })
      }
      loaded['lamina'] = true
      for (var d = 0; d < 5; d++) {
        loaded['rap' + d] = true
        rap = results[d + 2].split('\n')
        for (var i = 0; i < rap.length - 1; i++) {
          var split = rap[i].split('\t')
          var bin = segments[parseInt(split[0]) - 1][0] + (parseInt(split[1]) / (resolution == '1Mb' ? 1000000 : 40000))
          all[bin]['rap' + d] = parseFloat(split[4])
        }
      }
      for (var a = 0; a < all.length; a++) {
        var binA = all[a]
        binA.contacts = []
        for (var b = 0; b < all.length; b++) {
          if (a == b) continue
          var binB = all[b]
          var distance = distanceToSquared(binA.x3, binA.y3, binA.z3, binB.x3, binB.y3, binB.z3)
          binA.contacts.push(distance)

          var ic = chromosomes[binA.chromosome].contacts[binB.chromosome]
          chromosomes[binA.chromosome].contacts[binB.chromosome] = ic == null ? 0 : ic + distance
        }
      }
      for (var i = 0; i < chromosomes.length; i++) {
        var binsA = segments[i][1] - segments[i][0]
        chromosomes[i].weighted = [] // this is fair but isolates non-localized chromosomes (like active X)
        for (var j = 0; j < chromosomes[i].contacts.length; j++) {
          var binsB = segments[j][1] - segments[j][0]
          chromosomes[i].weighted.push(chromosomes[i].contacts[j] / (binsA + binsB))
        }
      }
      if (launch) init()
      // plotGenome()
      graphGenome()
      modelGenome()
    })
}

function init() {
  launch = false

  graph.svg = d3.select('#graph').append('svg')
    .attr('width', width / 2)
    .attr('height', height)
  graph.floor = graph.svg.append('g').call(zoom)
  graph.floor.append('rect')
    .attr('width', width / 2)
    .attr('height', height)
    .attr('opacity', 0)
  graph.container = graph.svg.append('g')
  graph.layer1 = graph.container.append('g')
  graph.layer2 = graph.container.append('g')
  graph.layer3 = graph.svg.append('g')
  graph.layer4 = graph.svg.append('g')

  matrix.svg = d3.select('#matrix').append('svg')
    .attr('width', 200)
    .attr('height', 200)
  matrix.layer1 = matrix.svg.append('g')
  matrix.layer2 = matrix.svg.append('g')

  scene = new THREE.Scene()
  camera = new THREE.PerspectiveCamera(75, width / height / 2, 1, 20000)
  scene.add(camera)
  renderer = new THREE.WebGLRenderer()
  renderer.setSize(width / 2, height)
  d3.select('#model')[0][0].appendChild(renderer.domElement)
  controls = new THREE.TrackballControls(camera, renderer.domElement)

  window.addEventListener('resize', onWindowResize, false)
  document.addEventListener('mousemove', onDocumentMouseMove, false)
  document.addEventListener('keyup', onDocumentKeyUp, false)

  navigation.push({
    'node': 'chromosome',
    'link': 'weighted',
    'locus': new THREE.Vector3(0, 0, 0),
  })

  $('#navigation').on('click', '.nav', function(){
    navigate($('#navigation>.nav').index(this))
  })

  animate()

}

function navigate(nav) {
  $('#navigation>.nav').addClass('inactive')
  $('#navigation>.nav:eq(' + nav + ')').removeClass('inactive')

  controls.target.copy(navigation[nav].locus)
  camera.position.copy(navigation[nav].locus)
  camera.position.setZ(30)
  graph.container.attr('transform', 'scale(1)')

  if (navigation[nav].node == 'chromosome') {
    graphGenome()
    for (var i = 0; i < chromosomes.length; i++) {
      var alphas = new Float32Array(bufferGeometry[i].attributes.position.count)
      for (var a = 0; a < bufferGeometry[i].attributes.position.count; a++) alphas[a] = 0.8
      bufferGeometry[i].attributes.alpha = new THREE.BufferAttribute(alphas, 1)
    }
  } else if (navigation[nav].node == '1Mb') {
    graphChromosomes(navigation[nav].chromosomes)
    for (var i = 0; i < chromosomes.length; i++) {
      var alphas = new Float32Array(bufferGeometry[i].attributes.position.count)
      if (navigation[nav].chromosomes.indexOf(i) > -1) for (var a = 0; a < bufferGeometry[i].attributes.position.count; a++) alphas[a] = 0.8
      else for (var a = 0; a < bufferGeometry[i].attributes.position.count; a++) alphas[a] = 0
      bufferGeometry[i].attributes.alpha = new THREE.BufferAttribute(alphas, 1)
    }
  }

  $('#node').val(navigation[nav].node)
  $('#link').val(navigation[nav].link)

  navigated = nav
}

function search(query) {
  // TODO: remember pinned
  if (!loaded[query]) return alert("search not found")

  if (navigation[navigated].node == 'chromosome') {
    for (var i = 0; i < chromosomes.length; i++) {
      var segment = segments[i]
      chromosomes[i].found = 0
      for (var j = segment[0]; j < segment[1]; j++) {
        chromosomes[i].found += all[j][query]
      }
      chromosomes[i].found /= (segment[1] - segment[0])
    }
    max = 0
    for (var i = 0; i < chromosomes.length; i++) {
      if (chromosomes[i].found > max) max = chromosomes[i].found
    }
    graph.svg.selectAll('.node').attr('opacity', function(d){ return d.found / max })
    for (var i = 0; i < chromosomes.length; i++) {
      var alphas = new Float32Array(bufferGeometry[i].attributes.position.count)
      for (var a = 0; a < bufferGeometry[i].attributes.position.count; a++) alphas[a] = chromosomes[i].found / max
      bufferGeometry[i].attributes.alpha = new THREE.BufferAttribute(alphas, 1)
    }
  } else if (navigation[navigated].node == '1Mb') {
    for (var i = 0; i < all.length; i++) {

    }
  }
}

function modelGenome() {

  scene.remove(genome)
  genome = new THREE.Object3D()
  meshes = []

  for (var i = 0; i < segments.length; i++) {
    var segment = segments[i]
    var curve = new THREE.CatmullRomCurve3(
      all.slice(segment[0], segment[1]).map(function(values, bin){
        return new THREE.Vector3((values.x3 - 100), (values.y3 - 100), (values.z3 - 100))
      })
    )

    var geometry = new THREE.TubeGeometry(
      curve,  //path
      (segments[i % segments.length][1] - segments[i % segments.length][0]) * (resolution == '1Mb' ? 5 : 2),    //segments
      resolution == '1Mb' ? 0.05 : 0.1,     //radius
      3,     //radiusSegments
      false  //closed
    )
    bufferGeometry[i] = new THREE.BufferGeometry().fromGeometry(geometry)
    var alphas = new Float32Array(bufferGeometry[i].attributes.position.count)
    var colors = new Float32Array(bufferGeometry[i].attributes.position.count * 3)
    var color = d3.rgb(rainbow(i))
    for (var v = 0; v < bufferGeometry[i].attributes.position.count; v++) {
      alphas[v] = 0.8
      colors[(v * 3)] = color.r / 255
      colors[(v * 3) + 1] = color.g / 255
      colors[(v * 3) + 2] = color.b / 255
    }
    bufferGeometry[i].attributes.alpha = new THREE.BufferAttribute(alphas, 1)
    bufferGeometry[i].attributes.color = new THREE.BufferAttribute(colors, 3)
    material = new THREE.ShaderMaterial({
      vertexShader: document.getElementById('vertexShader').textContent,
      fragmentShader: document.getElementById('fragmentShader').textContent,
      vertexColors: THREE.VertexColors,
      transparent: true,
    })
    meshes[i] = new THREE.Mesh(bufferGeometry[i], material)
    meshes[i].name = i
    genome.add(meshes[i])
  }
  scene.add(genome)

  camera.position.z = resolution == '1Mb' ? 30 : 60

}

function plotGenome() {
  var size = 200 / 40

  var mg = matrix.genome = {}

  var row = matrix.layer1.selectAll('.row')
    .data(chromosomes)
  var rowEnter = row.enter().append('g')
    .attr('transform', function(d,i){ return 'translate(0,' + (d.chromosome * size) + ')' })
    .attr('class', 'row')
  rowEnter.each(function(d){
    var rowThis = d3.select(this)
    d.weighted.forEach(function(contact,c){
      contact = 255 - contact / 25
      rowThis.append('rect')
        .attr('width', size)
        .attr('height', size)
        .attr('y', 0)
        .attr('x', c * size)
        .attr('fill', d.chromosome == c ? rainbow(c) : d3.rgb(contact, contact, contact))
    })
  })
}

function graphGenome() {
  graph.svg.selectAll('.node,.link').remove()
  pinned = 0
  for (var i = 0; i < chromosomes.length; i++) chromosomes[i].pinned = false

  var gg = graph.genome = {}
  gg.force = d3.layout.force()
    .size([width / 2, height])
    .charge(-300)
    .linkStrength(function(d){ return Math.sqrt(d.distance) / 500 })
  gg.nodes = chromosomes
  gg.links = []
  gg.linked = {}

  for (var i = 0; i < gg.nodes.length; i++) {
    var chromosome = gg.nodes[i]
    for (var j = 0; j < gg.nodes.length; j++) {
      if (chromosome.weighted[j] < 6000 && gg.linked[j] == null) {
        gg.links.push({'source': i, 'target': j, 'distance': chromosome.weighted[j]})
        gg.linked[i] = true
      }
    }
  }

  var node = graph.layer2.selectAll('.node')
    .data(gg.nodes)
  var nodeEnter = node.enter().append('g')
    .attr('class', 'node chromosome')
  nodeEnter.append('circle')
    .attr('r', 8)
    .attr('stroke', '#333')
    .attr('stroke-width', 3)
    .attr('fill', function(d,i){ return rainbow(i) })
  nodeEnter.append('text')
    .text(function(d,i){ return (i % 20) == 19 ? "X" : (i % 20) + 1 })
    .attr('fill', '#333')
    .attr('font-size', '8px')
    .attr('y', 3)
    .attr('text-anchor', 'middle')
    .attr('font-weight', 700)
  nodeEnter.on('mouseover', function(d){
    if (pinned == 0) d3.selectAll('.chromosome').attr('opacity', 0.2)
    else d3.selectAll('.chromosome').attr('opacity', function(d,i){ return d.pinned ? 1 : 0.2 })
    d3.select(this).attr('opacity', 1)
    for (var i = 0; i < segments.length; i++) {
      var alphas = new Float32Array(bufferGeometry[i].attributes.position.count)
      if (i == d.chromosome || chromosomes[i].pinned) for (var a = 0; a < bufferGeometry[i].attributes.position.count; a++) alphas[a] = 0.8
      else for (var a = 0; a < bufferGeometry[i].attributes.position.count; a++) alphas[a] = 0.2
      bufferGeometry[i].attributes.alpha = new THREE.BufferAttribute(alphas, 1)
    }
  })
  nodeEnter.on('mouseout', function(d){
    if (pinned == 0) d3.selectAll('.chromosome').attr('opacity', 1)
    else d3.selectAll('.chromosome').attr('opacity', function(d,i){ return d.pinned ? 1 : 0.2 })
    for (var i = 0; i < segments.length; i++) {
      var alphas = new Float32Array(bufferGeometry[i].attributes.position.count)
      if (pinned == 0 || chromosomes[i].pinned) for (var a = 0; a < bufferGeometry[i].attributes.position.count; a++) alphas[a] = 0.8
      else for (var a = 0; a < bufferGeometry[i].attributes.position.count; a++) alphas[a] = 0.2
      bufferGeometry[i].attributes.alpha = new THREE.BufferAttribute(alphas, 1)
    }
  })
  nodeEnter.on('click', function(d){
    d.pinned = !d.pinned
    if (d.pinned) pinned++
    else pinned--
    chromosomes[d.chromosome] = d
  })

  var link = graph.layer1.selectAll('.link')
    .data(gg.links).enter().append('line')
    .attr('stroke-width', 2)
    .attr('stroke', '#555')
    .attr('opacity', 1)
    .attr('class', 'link interchromosomal')

  gg.context = makeAbsoluteContext(graph.layer2[0][0], graph.svg[0][0])

  gg.force
    .nodes(gg.nodes)
    .links(gg.links)
    .start()
  for (var i = 0; i < Math.pow(gg.nodes.length, 2); i++) gg.force.tick()
  gg.force.stop()
  node
    .attr('transform', function(d,i){ return 'translate(' + d.x + ',' + d.y + ')'})
  link
    .attr('x1', function(d){ return d.source.x })
    .attr('y1', function(d){ return d.source.y })
    .attr('x2', function(d){ return d.target.x })
    .attr('y2', function(d){ return d.target.y })
}

function graphChromosomes(chr) {
  graph.svg.selectAll('.node,.link').remove()

  graphed = true
  var cg = graph.chromosomes = {}
  cg.force = d3.layout.force()
    .size([width / 2, height])
    .linkDistance(function(d){ return d.distance * 3 })
    .charge(-10)
  cg.nodes = []
  cg.links = []
  cg.linked = {}

  for (var i = 0; i < chr.length; i++) {
    var segment = segments[chr[i]]
    for (var j = segment[0]; j < segment[1]; j++) {
      cg.nodes.push(all[j])
    }
  }

  for (var i = 0; i < cg.nodes.length; i++) {
    var bin = cg.nodes[i]
    for (var j = 0; j < cg.nodes.length; j++) {
      var con = cg.nodes[j].bin
      if (bin.contacts[con] < 5 && cg.linked[con] == null) {
        cg.links.push({'source': i, 'target': j, 'distance': bin.contacts[con]})
        cg.linked[bin.bin] = true
      }
    }
  }

  var node = graph.layer2.selectAll('.node')
    .data(cg.nodes)
  var nodeEnter = node.enter().append('g')
    .attr('class', 'node bin')
  nodeEnter.append('circle')
    .attr('r', 3)
    .attr('stroke', '#333')
    .attr('stroke-width', 2)
    .attr('fill', function(d){ return rainbow(d.chromosome) })

  var link = graph.layer1.selectAll('.link')
    .data(cg.links).enter().append('line')
    .attr('stroke-width', 1)
    .attr('stroke', '#fff')
    .attr('opacity', 0.2)
    .attr('class', 'link interbin')

  cg.force
    .nodes(cg.nodes)
    .links(cg.links)
    .start()
  for (var i = 0; i < Math.pow(cg.nodes.length, 2); i++) cg.force.tick()
  cg.force.stop()
  node
    .attr('transform', function(d,i){ return 'translate(' + d.x + ',' + d.y + ')'})
  link
    .attr('x1', function(d){ return d.source.x })
    .attr('y1', function(d){ return d.source.y })
    .attr('x2', function(d){ return d.target.x })
    .attr('y2', function(d){ return d.target.y })

}

function animate() {
  requestAnimationFrame(animate)
  stats.begin()
  controls.update()
  render()
  stats.end()
}

function render() {
  renderer.render(scene, camera)
}

function onWindowResize() {
  width = window.innerWidth
  height = window.innerHeight
  graph.container.attr('transform', 'translate(' + ((width - initialWidth) / 4) + ',0)scale(' + (height / initialHeight) + ')')
  graph.svg.attr('width', width / 2).attr('height', height)
  // graph.genome.force.size([width / 2, height])
  camera.aspect = width / height / 2
  camera.updateProjectionMatrix()
  renderer.setSize(width / 2, height)
}

function onDocumentMouseMove(event) {
  event.preventDefault()
  mouse.x = event.clientX
  mouse.y = event.clientY
}

function onDocumentKeyUp(event) {
  event.preventDefault()
  if (navigated > 0 && (event.keyCode == 8 || event.keyCode == 46)) {
    navigated--
    navigate(navigated)
  }
  if (event.keyCode != 13) return
  var val = $('#search').val()
  if (val.length == 0 && pinned == 0) {
    navigate(navigation.length - 1)
  } else if (val.length > 0) {
    search(val)
  } else if (pinned > 0) {
    var pin = []
    var locus
    for (var i = 0; i < chromosomes.length; i++) {
      if (chromosomes[i].pinned) {
        pin.push(i)
        var center = bufferGeometry[i].boundingSphere.center
        locus = locus == null ? center : locus.add(center)      }
    }
    locus.divideScalar(pin.length)

    $('#navigation').append("<div class='nav'><span>&acd;</span> chromosome " + pin.toString() + "</div>")
    // &there4;

    navigation.push({
      'node': '1Mb',
      'link': 'distance',
      'chromosomes': pin,
      'locus': locus,
    })
    navigate(navigation.length - 1)

  }
}

function distanceToSquared(x1, y1, z1, x2, y2, z2) {
  return Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2) + Math.pow(z2 - z1, 2)
}

function zoomed() {
  graph.container.selectAll('.node').selectAll('circle,text').attr('transform', 'scale(' + (((zoomToBin + 2) - d3.event.scale) / (zoomToBin + 1)) + ')')
  graph.container.attr('transform', 'translate(' + d3.event.translate + ')scale(' + d3.event.scale + ')')
}

function dragstarted(d) {
  d3.event.sourceEvent.stopPropagation()
  d3.select(this).classed('dragging', true)
}

function dragged(d) {
  d3.select(this).attr('cx', d.x = d3.event.x).attr("cy", d.y = d3.event.y)
}

function dragended(d) {
  d3.select(this).classed('dragging', false)
}

function makeAbsoluteContext(element, svgDocument) {
  return function(x,y) {
    var offset = svgDocument.getBoundingClientRect()
    var matrix = element.getScreenCTM()
    return {
      x: (matrix.a * x) + (matrix.c * y) + matrix.e - offset.left,
      y: (matrix.b * x) + (matrix.d * y) + matrix.f - offset.top
    }
  }
}

</script>
</html>
