<html>
<script src='js/three.min.js'></script>
<script src='js/jquery.js'></script>
<script src='js/d3.js'></script>
<script src='js/CanvasRenderer.js'></script>
<script src='js/Projector.js'></script>
<script src='js/stats.js'></script>
<script src='js/queue.js'></script>
<style>
html, body {
  margin: 0;
  padding: 0;
  font-family: 'Helvetica Neue';
  color: #ffffff;
  text-transform: uppercase;
  font-size: 10px;
  background-color: #000;
}
#controls {
  padding: 10px;
  background: none;
  position: absolute;
}
#controls .border {
  border: 2px solid #fff;
  border-radius: 3px;
  width: 10px;
  height: 10px;
  margin: 2px;
  padding: 0;
  float: left;
  cursor: pointer;
}
#graph {
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
}
</style>
<body>
  <svg id='graph'></svg>
  <div id='controls'>
    <!-- <form id='resolution'>
      resolution<br>
      <input id='1Mb' type="radio" name="resolution" value="1Mb" checked> 1Mb
      <input id='40kb' type="radio" name="resolution" value="40kb"> 40kb
    </form> -->
  </div>
</body>
<script>

var resolution = '1Mb',
    hour = 0,

    all = [],
    pdb,
    pml,
    rap,

    nodes,
    links = [],

    width = window.innerWidth,
    height = window.innerHeight

var svg = d3.select('#graph')
  .attr('width', width)
  .attr('height', height)
var layers = [svg.append('g'), svg.append('g'), svg.append('g')]

var force = d3.layout.force()
  .size([width, height])
  .charge(0)
  .linkStrength(0)
  .linkDistance(5)
  .on('tick', function(e) {
    var k = e.alpha * 0.1
    d3.selectAll('.node')
      .each(function(o,j){
        // o.x += (width / 2 + (o.x3 - 100) * 100 - o.x) * k
        // o.y += (height / 2 + (o.y3 - 110) * 100 - o.y) * k
        o.y += (height / 2 + (o.bin) * 10 - 1000 - o.y) * k
        if (o.rap[hour].ratio != null) o.x += (width / 2 + (o.rap[hour].ratio) * 10 - 500 - o.x) * k
        else o.x += (width / 2 + (0) * 10 - 500 - o.x) * k
      })
      .attr('transform', function(d){ return 'translate(' + d.x + ',' + d.y + ')' })
    d3.selectAll('.link')
      .attr('x1', function(d){ return d.source.x })
      .attr('y1', function(d){ return d.source.y })
      .attr('x2', function(d){ return d.target.x })
      .attr('y2', function(d){ return d.target.y })
  })

function requestData(url, callback) {
  var req = new XMLHttpRequest
  req.open("GET", url, true)
  req.setRequestHeader("Accept", "application/json")
  req.onreadystatechange = function() {
    if (req.readyState === 4) {
      if (req.status < 300) callback(null, JSON.parse(req.responseText))
      else callback(req.status)
    }
  }
  req.send(null)
}

function loadGenome(resolution) {
  var q = queue(1)
  q.defer(d3.text, 'data/Model_' + resolution + '.pdb')
  q.defer(d3.text, 'data/Model_' + resolution + '.pml')
  q.defer(d3.text, 'data/0hr-Xist_' + resolution)
  q.defer(d3.text, 'data/1hr-Xist_' + resolution)
  q.defer(d3.text, 'data/2hr-Xist_' + resolution)
  q.defer(d3.text, 'data/3hr-Xist_' + resolution)
  q.defer(d3.text, 'data/6hr-Xist_' + resolution)
  q.awaitAll(function(error, results){
      pdb = results[0].split('\n')
      for (var i = 0; i < pdb.length - 1; i++) {
        all.push({
          'bin': i,
          'x3': parseFloat(pdb[i].substring(31,37)),
          'y3': parseFloat(pdb[i].substring(38,45)),
          'z3': parseFloat(pdb[i].substring(46,53)),
          'lamina': parseInt(pdb[i].substring(61,64)),
          'rap': {0: {}, 1: {}, 2: {}, 3: {}, 4: {}}
        })
      }
      pml = results[1].split('\n')
      for (var i = pml.length - 1; i >= 0; i--) {
        var line = pml[i]
        if (line.substring(0, 6) != "select") pml.splice(i, 1)
        else {
          var split = pml[i].split(' ')[2].split('-')
          pml[i] = [parseInt(split[0]), parseInt(split[1])]
        }
      }
      pml.reverse()
      for (var d = 0; d < 5; d++) {
        rap = results[d + 2].split('\n')
        for (var i = 0; i < rap.length - 1; i++) {
          var split = rap[i].split('\t')
          var bin = parseInt(split[1]) / (resolution == '1Mb' ? 1000000 : 40000) + -1 + pml[parseInt(split[0] - 1) % pml.length][0]
          all[bin].rap[d].expected = parseFloat(split[2])
          all[bin].rap[d].actual = parseFloat(split[3])
          all[bin].rap[d].ratio = parseFloat(split[4])
        }
      }
      plotSteps(all)
    })
}

function plotSteps(data) {
  var w = 20
  var h = 0.1
  var row = svg.selectAll('.bin')
    .data(data)
  var rowEnter = row.enter().append('g')
    .attr('transform', function(d){ return 'translate(0,' + d.bin * h + ')' })
    .attr('class', 'bin')
  for (var hr = 0; hr < 5; hr++) {
    rowEnter.append('rect')
      .attr('width', w)
      .attr('height', h)
      .attr('x', hr * w)
      .attr('fill', function(d){
        var ratio = d.rap[hr].ratio
        if (ratio == null) return '#000'
        if (ratio > 1) return d3.rgb(0, 0, (ratio / 20) * 255)
        else return d3.rgb(Math.abs(ratio - 1) * 255, 0, 0)
      })
  }
  rowEnter.append('rect')
    .attr('width', w)
    .attr('height', h)
    .attr('x', 5 * w + 1)
    .attr('fill', function(d){ return d.lamina ? '#0f0' : '#f00' })
  rowEnter.append('rect')
    .attr('width', w)
    .attr('height', h)
    .attr('x', 6 * w + 2)
    .attr('fill', function(d){ return d3.rgb((d.x3 - 80) * 10, (d.y3 - 80) * 10, (d.z3 - 80) * 10) })
  for (var chr = 0; chr < pml.length; chr++) {
    svg.append('line')
      .attr('stroke', '#000')
      .attr('x1', 0)
      .attr('x2', 7 * w + 2)
      .attr('y1', pml[chr][1] * h)
      .attr('y2', pml[chr][1] * h)
  }
}

function chromosome(id) {
  return all.slice(pml[id][0] - 1, pml[id][1] - 1)
}

loadGenome(resolution)

</script>
</html>
