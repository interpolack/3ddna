<html>
<script src='js/three.min.js'></script>
<script src='js/jquery.js'></script>
<script src='js/d3.js'></script>
<script src='js/CanvasRenderer.js'></script>
<script src='js/TrackballControls.js'></script>
<script src='js/Projector.js'></script>
<script src='js/stats.js'></script>
<script src='js/queue.js'></script>
<style>
html, body {
  margin: 0;
  padding: 0;
  font-family: 'Helvetica Neue';
  color: #ffffff;
  text-transform: uppercase;
  font-size: 10px;
}
#graph {
  float: left;
  display: inline-block;
  width: 50%;
  height: 100%;
  background-color: #333;
  margin: 0;
  padding: 0;
}
#model {
  float: left;
  display: inline-block;
  width: 50%;
  height: 100%;
  background-color: #000;
  margin: 0;
  padding: 0;
}
.node {
  cursor: pointer;
}
.link {
  cursor: pointer;
}
</style>
<body>
  <div id='graph'>
  </div>
  <div id='model'>
  </div>
</body>
<script type='x-shader/x-vertex' id='vertexShader'>
varying vec2 vUv;
varying float noise;
attribute float alpha;
varying float vAlpha;
varying vec3 vColor;
void main() {
  vAlpha = alpha;
  vUv = uv;
  vColor = color;
  gl_PointSize = 1.1;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
</script>
<script type="x-shader/x-fragment" id="fragmentShader">
varying vec2 vUv;
varying float noise;
varying float vAlpha;
varying vec3 vColor;
uniform vec3 colorsa;
void main() {
  gl_FragColor = vec4(vColor, vAlpha);
}
</script>
<script>

var rainbow = d3.scale.category20(),

    cgSize = 300,
    graphCap = 1000,
    graphThreshold = 4,
    mapCap,

    graph = {},
    width = window.innerWidth,
    height = window.innerHeight,

    all = [],
    pdb = [],
    segments = [],
    rap = [],
    chromosomes = [],

    mouse = {'x': 0, 'y': 0},

    zoomToBin = 10,
    graphed = false,
    launch = true

var zoom = d3.behavior.zoom()
  .scaleExtent([1, 20])
  .on("zoom", zoomed)

var drag = d3.behavior.drag()
  .origin(function(d) { return d; })
  .on("dragstart", dragstarted)
  .on("drag", dragged)
  .on("dragend", dragended)

var stats = new Stats()
stats.showPanel(1)
document.body.appendChild(stats.dom)

loadPDB('1Mb')

function loadPDB(resolution) {
  all = []
  pdb = []
  segments = []
  rap = []
  chromosomes = []

  var q = queue(1)
  q.defer(d3.text, 'data/Model_' + resolution + '.pdb')
  q.defer(d3.text, 'data/Model_' + resolution + '.pml')
  q.defer(d3.text, 'data/0hr-Xist_' + resolution)
  q.defer(d3.text, 'data/1hr-Xist_' + resolution)
  q.defer(d3.text, 'data/2hr-Xist_' + resolution)
  q.defer(d3.text, 'data/3hr-Xist_' + resolution)
  q.defer(d3.text, 'data/6hr-Xist_' + resolution)
  q.awaitAll(function(error, results){
      segments = results[1].split('\n')
      for (var i = segments.length - 1; i >= 0; i--) {
        var line = segments[i]
        if (line.substring(0, 6) != "select") segments.splice(i, 1)
        else {
          var split = segments[i].split(' ')[2].split('-')
          segments[i] = [parseInt(split[0]), parseInt(split[1])]
        }
      }
      segments.reverse()
      var length = segments.length
      var last = segments[length - 1][1] - 1
      for (var i = 0; i < length; i++) {
        chromosomes.push({
          'chromosome': i,
          'contacts': new Array(resolution == '40kb' ? length * 2 : length)
        })
        if (resolution == '40kb') segments.push([segments[i][0] + last - 1, segments[i][1] + last - 1])
      }
      pdb = results[0].split('\n')
      chromosome = 0
      for (var i = 0; i < pdb.length - 1; i++) {
        if (i > segments[chromosome][1]) chromosome++
        all.push({
          'chromosome': chromosome,
          'bin': i,
          'x3': parseFloat(pdb[i].substring(31,37)),
          'y3': parseFloat(pdb[i].substring(38,45)),
          'z3': parseFloat(pdb[i].substring(46,53)),
          'lamina': parseInt(pdb[i].substring(61,64)),
          'rap': {0: {}, 1: {}, 2: {}, 3: {}, 4: {}}
        })
      }
      for (var d = 0; d < 5; d++) {
        rap = results[d + 2].split('\n')
        for (var i = 0; i < rap.length - 1; i++) {
          var split = rap[i].split('\t')
          var bin = parseInt(split[1]) / (resolution == '1Mb' ? 1000000 : 40000)
          all[bin].rap[d].expected = parseFloat(split[2])
          all[bin].rap[d].actual = parseFloat(split[3])
          all[bin].rap[d].ratio = parseFloat(split[4])
        }
      }
      for (var a = 0; a < all.length; a++) {
        var binA = all[a]
        binA.contacts = []
        var bins = segments[binA.chromosome][1] - segments[binA.chromosome][0]
        for (var b = 0; b < all.length; b++) {
          if (a == b) continue
          var binB = all[b]
          var distance = distanceToSquared(binA.x3, binA.y3, binA.z3, binB.x3, binB.y3, binB.z3)
          binA.contacts.push(distance)

          var ic = chromosomes[binA.chromosome].contacts[binB.chromosome]
          chromosomes[binA.chromosome].contacts[binB.chromosome] = ic == null ? 0 : ic + (distance / bins)
        }
      }
      if (launch) init()
      graphGenome()
    })
}

function init() {
  launch = false

  graph.svg = d3.select('#graph').append('svg')
    .attr('width', width / 2)
    .attr('height', height)
  graph.floor = graph.svg.append('g').call(zoom)
  graph.floor.append('rect')
    .attr('width', width / 2)
    .attr('height', height)
    .attr('opacity', 0)
  graph.container = graph.svg.append('g')
  graph.layer1 = graph.container.append('g')
  graph.layer2 = graph.container.append('g')
  graph.layer3 = graph.svg.append('g')
  graph.layer4 = graph.svg.append('g')

  window.addEventListener('resize', onWindowResize, false)
  document.addEventListener('mousemove', onDocumentMouseMove, false)

}

function graphGenome() {
  var gg = graph.genome = {}
  gg.force = d3.layout.force()
    .size([width / 2, height])
    .charge(-300)
    .linkStrength(function(d){ return Math.sqrt(d.distance) / 500 })
  gg.nodes = chromosomes
  gg.links = []
  gg.linked = {}

  for (var i = 0; i < gg.nodes.length; i++) {
    var chromosome = gg.nodes[i]
    for (var j = 0; j < gg.nodes.length; j++) {
      if (chromosome.contacts[j] < 10000 && gg.linked[j] == null) {
        gg.links.push({'source': i, 'target': j, 'distance': chromosome.contacts[j]})
        gg.linked[i] = true
      }
    }
  }

  var node = graph.layer2.selectAll('.node')
    .data(gg.nodes)
  var nodeEnter = node.enter().append('g')
    .attr('class', 'node chromosome')
  nodeEnter.append('circle')
    .attr('r', 8)
    .attr('stroke', '#333')
    .attr('stroke-width', 3)
    .attr('fill', function(d,i){ return rainbow(i) })
  nodeEnter.append('text')
    .text(function(d,i){ return (i % 20) == 19 ? "X" : (i % 20) + 1 })
    .attr('fill', '#333')
    .attr('font-size', '8px')
    .attr('y', 3)
    .attr('text-anchor', 'middle')
    .attr('font-weight', 700)

  var link = graph.layer1.selectAll('.link')
    .data(gg.links).enter().append('line')
    .attr('stroke-width', 2)
    .attr('stroke', '#555')
    .attr('opacity', 1)
    .attr('class', 'link interchromosomal')

  gg.context = makeAbsoluteContext(graph.layer2[0][0], graph.svg[0][0])

  gg.force
    .nodes(gg.nodes)
    .links(gg.links)
    .start()
  for (var i = 0; i < Math.pow(gg.nodes.length, 2); i++) gg.force.tick()
  gg.force.stop()
  node
    .attr('transform', function(d,i){ return 'translate(' + d.x + ',' + d.y + ')'})
  link
    .attr('x1', function(d){ return d.source.x })
    .attr('y1', function(d){ return d.source.y })
    .attr('x2', function(d){ return d.target.x })
    .attr('y2', function(d){ return d.target.y })
}

function graphChromosomes(chromosomes) {
  graphed = true
  var cg = graph.chromosomes = {}
  cg.force = d3.layout.force()
    .size([width / 2, height])
    .linkDistance(function(d){ return d.distance * 3 })
    .charge(-10)
  cg.nodes = []
  cg.links = []
  cg.linked = {}

  for (var i = 0; i < chromosomes.length; i++) {
    var segment = segments[chromosomes[i]]
    for (var j = segment[0] - 1; j < segment[1] - 1; j++) {
      cg.nodes.push(all[j])
    }
  }

  for (var i = 0; i < cg.nodes.length; i++) {
    var bin = cg.nodes[i]
    for (var j = 0; j < cg.nodes.length; j++) {
      var con = cg.nodes[j].bin
      if (bin.contacts[con] < 4 && cg.linked[con] == null) {
        cg.links.push({'source': i, 'target': j, 'distance': bin.contacts[con]})
        cg.linked[bin.bin] = true
      }
    }
  }

  var node = graph.layer4.selectAll('.node')
    .data(cg.nodes)
  var nodeEnter = node.enter().append('g')
    .attr('class', 'node bin')
  nodeEnter.append('circle')
    .attr('r', 3)
    .attr('stroke', '#333')
    .attr('stroke-width', 2)
    .attr('fill', function(d){ return rainbow(d.chromosome) })

  var link = graph.layer3.selectAll('.link')
    .data(cg.links).enter().append('line')
    .attr('stroke-width', 1)
    .attr('stroke', '#fff')
    .attr('opacity', 0.2)
    .attr('class', 'link interbin')

  cg.force
    .nodes(cg.nodes)
    .links(cg.links)
    .start()
  for (var i = 0; i < Math.pow(cg.nodes.length, 2); i++) cg.force.tick()
  cg.force.stop()
  node
    .attr('transform', function(d,i){ return 'translate(' + d.x + ',' + d.y + ')'})
  link
    .attr('x1', function(d){ return d.source.x })
    .attr('y1', function(d){ return d.source.y })
    .attr('x2', function(d){ return d.target.x })
    .attr('y2', function(d){ return d.target.y })

}

function onWindowResize() {
  width = window.innerWidth
  height = window.innerHeight
  graph.attr('width', width / 2).attr('height', height)
  gg.force.size([width / 2, height])
}


function onDocumentMouseMove(event) {
  event.preventDefault()
  mouse.x = event.clientX
  mouse.y = event.clientY
}


function distanceToSquared(x1, y1, z1, x2, y2, z2) {
  return Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2) + Math.pow(z2 - z1, 2)
}

function zoomed() {
  graph.container.selectAll('.chromosome').selectAll('circle,text').attr('transform', 'scale(' + (((zoomToBin + 2) - d3.event.scale) / (zoomToBin + 1)) + ')').attr('opacity', ((zoomToBin + 1) - d3.event.scale) / (zoomToBin))
  graph.container.selectAll('.interchromosomal').attr('opacity', (5 - d3.event.scale) / 4)
  graph.container.attr('transform', 'translate(' + d3.event.translate + ')scale(' + d3.event.scale + ')')
  if (d3.event.scale > zoomToBin && !graphed) {
    var chromosomes = []
    for (var i = 0; i < graph.genome.nodes.length; i++) {
      var node = graph.genome.nodes[i]
      var pos = graph.genome.context(node.px, node.py)
      if (pos.x < width / 2 && pos.y < height && pos.x > 0 && pos.y > 0) chromosomes.push(i)
    }
    graphChromosomes(chromosomes)
  } else if (d3.event.scale <= zoomToBin && graphed) {
    graphed = false
    graph.svg.selectAll('.bin,.interbin').remove()
  }
}

function dragstarted(d) {
  d3.event.sourceEvent.stopPropagation()
  d3.select(this).classed('dragging', true)
}

function dragged(d) {
  d3.select(this).attr('cx', d.x = d3.event.x).attr("cy", d.y = d3.event.y)
}

function dragended(d) {
  d3.select(this).classed('dragging', false)
}

function makeAbsoluteContext(element, svgDocument) {
  return function(x,y) {
    var offset = svgDocument.getBoundingClientRect()
    var matrix = element.getScreenCTM()
    return {
      x: (matrix.a * x) + (matrix.c * y) + matrix.e - offset.left,
      y: (matrix.b * x) + (matrix.d * y) + matrix.f - offset.top
    }
  }
}

</script>
</html>
